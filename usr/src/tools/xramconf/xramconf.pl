#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright (c) 2008 NEC Corporation
# All rights reserved.
#

use strict;
use Config;
use File::Basename;
use FileHandle;
use POSIX;

my ($perl, @libs) = (@ARGV);
my $file = basename($0);
$file =~ s/\.pl$//;

my $out = FileHandle->new($file, O_WRONLY|O_CREAT|O_TRUNC, 0755) or
	die "Can't open ($file): $!\n";

print $out <<EOF;
#!$perl

use lib qw(@libs);

EOF

print $out <<'EOF';
#
# Copyright (c) 2008 NEC Corporation
# All rights reserved.
#

=head1 NAME

I<xramconf> - Built-in xramfs device configuration tool

=head1 SYNOPSIS

B<xramconf> -C|--create [-f <config-file>][-o outfile][-r]

B<xramconf> -R|--relocate [-r] vmunix

B<xramconf> -I|--image [-f <config-file>][-r][-o <unified-image>][-u <unix>]
            kernel-image infofile [mkimage-args]

B<xramconf> -L|--devlink [-f <config-file>] root-directory

B<xramconf> -D|--dump infofile

=head1 DESCRIPTION

I<xramconf> is a configuration tool for built-in xramfs device.
I<xramconf> must be invoked under OpenSolaris build environment
activated by I<bldenv>(1).

=head1 OPTIONS

I<xramconf> takes the following options:

=over 4

=item B<-C>|B<--create>

Create C language source code that defines xramfs device configuration
according to configuration file.

=item B<-R>|B<--relocate>

Relocate memory for xramfs devices.
This option requires an argument to specify kernel image path.

=item B<-I>|B<--image>

Create boot image information.
This option requires at least two arguments, file path to store kernel boot
image and file path to store warm boot information. The rest of arguments
are passed to B<mkimage>(1) command.

Note that the kernel boot image generated by this option is NOT U-boot image.

=item B<-L>|B<--devlink>

Create symbolic link to xramfs device in the specified root directory.
This options requires an argument to specify directory path that contains
the contents of root filesystem.

=item B<-D>|B<--dump>

Print warm boot information in the specified file to the standard
output. Warm boot information file, which is dumped by B<--image>,
must be specified as argument.

=item B<-o> I<file>

Specify output filename for B<-C> option.
If omitted, B<-C> option dumps source code to standard output.

If B<-o> is specified with B<-I> option, it means that the unified U-boot
image, which contains kernel and xramfs image, should be dumped into the
specified file.

=item B<-f>

Specify configuration file path that defines xramfs device configuration.
If omitted, "xramdev.conf" is used.

=item B<-r>

Remove output file on error.

=item B<-e> I<elfdatamod>

Specify file path to B<elfdatamod>(1) command.
If omitted, I<xramconf> tries to find it using B<PATH> environment variable.

=item B<-k>

Keep temporary files.
This option is useful for debug.

=item B<-q>

Suppress informatial message.

=item B<-u> I<unix>

Specify unix executable path for B<-I> option.
If omitted, I<xramconf> derives unix executable path from environment
variables.

=item B<-m> I<mkimage>

Specify file path to B<mkimage>(1) command in U-boot distribution.
If omitted, I<xramconf> tries to find it using B<PATH> environment variable.

=head1 FORMAT OF CONFIGURATION FILE

This section describes the format of xramfs device configuration file.

Each xramfs device must be declared by the following form:

  xramdev <name> {
          <property>:  <value>;
  }

<name> is a name of xramfs device node. It must start and end with an alphabet
(a-z, A-Z), and must consist of alphabet, digit, and '_'.
Length of <name> must be less than 32.
xramdev block can contain statement to define parameter. Each statement in
xramdev block must be a <property> and <value> separated by colon, and
statement must be ended with semicolon.

Each xramdev block must contain at least B<size> property.
B<size> declares the size of xramfs device in bytes.
Note that B<size> will be rounded up to the system pagesize.

The following example declares xramfs device that named "example".
Its size is 0x400000 bytes.

  xramdev example
  {
          size:         0x400000;
  }

The following optional parameters can be declared:

=over 4

=item B<prot>

Specify device protection.
Its value must be one of followings:

=over 4

=item I<readonly>

Read only device.
Any write access to the device will be refused.

=item I<writable>

Writable device.

=back

Default value is I<readonly>.

=item B<cache>

Specify cache attribute for the device.

Its value must be one of followings:

=over 4

=item I<on>

Device pages are mapped as cached.

=item I<off>

Device pages are mapped as uncached.

=item I<l1only>

ARM specific value.
Device pages are mapped as cached, but external caches are never used.

=back

Default value is I<on>.

=item B<rootfs>

Declares that the device is used as root filesystem device.
The value of this parameter must be one of I<true> or I<false>.
If omitted, I<xramconf> treats that the device is not a root filesystem device.

The following line declares the device is used as root filesystem device.

    rootfs:   true;

Only one xramfs device can be defined as root filesystem device.

=item B<sysdump>

Denotes that the xramfs device pages should be dumped into the system dump.
The value of this parameter must be one of I<true> or I<false>.
If omitted, the device pages will not be dumped.

The following line declares the device should be dumped into the system dump.

    sysdump:  true;

=head1 SEE ALSO

B<bldenv>(1), B<elfdatamod>(1)

=cut

use strict;
use Cwd qw(abs_path);
use Getopt::Long;
use FileHandle;
use File::Basename;
use File::Path;
use File::stat;
use POSIX;
use POSIX qw(:sys_wait_h);

use XRamConf::Constants;

use vars qw($PROGNAME @UNLINK $DO_UNLINK);

$PROGNAME = basename($0);

sub usage($);
sub create_source($$);
sub relocate_device($$);
sub create_image(%);
sub update_devlink($$);
sub dump_infofile($);
sub dump_index($);
sub load_parser($);
sub load_kern_handle($);

END {
	my $status = $?;
	if ($status) {
		# Unlink output files.
		foreach my $f (@UNLINK) {
			print STDERR "*** Remove $f\n";
			unlink($f);
		}
	}
}

MAIN:
{
	Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

	my ($help, $create, $relocate, $image, $conffile, $outfile,
	    $elfdatamod, $mkimage, $keep, $quiet, $vmunix, $devlink,
	    $dumpinfo, $dumpindex);
	usage(2) unless (GetOptions
			 ('C|create'	=> \$create,
			  'R|relocate'	=> \$relocate,
			  'I|image'	=> \$image,
			  'L|devlink'	=> \$devlink,
			  'D|dump'	=> \$dumpinfo,
			  'dump-index'	=> \$dumpindex,
			  'f=s'		=> \$conffile,
			  'o=s'		=> \$outfile,
			  'r'		=> \$DO_UNLINK,
			  'e=s'		=> \$elfdatamod,
			  'm=s'		=> \$mkimage,
			  'k'		=> \$keep,
			  'q'		=> \$quiet,
			  'u=s'		=> \$vmunix,
			  'help'	=> \$help));

	usage(0) if ($help);

	$conffile = 'xramdev.conf' unless ($conffile);
	my $exc = 0;

	$exc++ if ($create);
	$exc++ if ($relocate);
	$exc++ if ($image);
	$exc++ if ($dumpindex);
	$exc++ if ($devlink);
	$exc++ if ($dumpinfo);
	usage(1) if ($exc != 1);

	if ($elfdatamod) {
		require XRamConf::Elf;
		import XRamConf::Elf;

		$XRamConf::Elf::ELFDATAMOD = $elfdatamod;
	}

	eval {
		my $mach = $ENV{MACH};
		die "Environment variable \"MACH\" is not defined.\n"
			unless ($mach);

		if ($create) {
			create_source($conffile, $outfile);
			last MAIN;
		}
		if ($relocate) {
			usage(1) unless (@ARGV == 1);
			relocate_device($ARGV[0], $mach);
			last MAIN;
		}
		if ($image) {
			usage(1) unless (@ARGV >= 2);
			my $kernel = shift(@ARGV);
			my $infofile = shift(@ARGV);
			create_image(vmunix => $vmunix,
				     kernel => $kernel,
				     infofile => $infofile,
				     conffile => $conffile,
				     unified => $outfile,
				     keep => $keep,
				     quiet => $quiet,
				     mkimage => $mkimage,
				     image_args => \@ARGV);
			last MAIN;
		}
		if ($devlink) {
			usage(1) unless (@ARGV == 1);
			update_devlink($conffile, $ARGV[0]);
			last MAIN;
		}
		if ($dumpinfo) {
			usage(1) unless (@ARGV == 1);
			dump_infofile($ARGV[0]);
			last MAIN;
		}
		if ($dumpindex) {
			usage(1) unless (@ARGV == 1);
			dump_index($ARGV[0]);
			last MAIN;
		}
	};
	if ($@) {
		my $err = "$@";
		chomp($err);

		die "*** xramconf error: $err\n";
	}
}

sub usage($)
{
	my ($status) = @_;

	my $out = ($status) ? \*STDERR : \*STDOUT;
	print $out <<OUT;
Usage: $PROGNAME -C|--create [-f <config-file>][-o <outfile>]
Usage: $PROGNAME -R|--relocate vmunix
Usage: $PROGNAME -I|--image [-f <config-file>][-i <unified-image>][-u <unix>]
       kernel-image infofile [mkimage-args]
Usage: $PROGNAME -L|--devlink [-f <config-file>] root-directory
Usage: $PROGNAME -D|--dump infofile

OUT

	if ($status) {
		print $out <<OUT;
Try "$PROGNAME --help".
OUT
	}
	else {
		print $out <<OUT;
Options:

  -C|--create
      Dump C language source code that declares xramfs device configuration.

  -R|--relocate
      Relocate memory for xramfs device.

  -I|--image
      Create boot image information..

  -L|--devlink
      Update symbolic links to xramdev device in the specified root directory.

  -D|--dump
      Dump warm boot information in the specified file.

  -f <config-file>
      Specify xramfs device configuration file path.

  -o <outfile>
      Specify output filename for -C option.

  -r
      Remove output file on error.

  -e <elfdatamod>
      Specify path to elfdatamod(1) command.

  -i <unified-image>
      Create unified U-boot image file.

  -u <unix>
      Specify path to unix executable.

  -m <mkimage>
      Specify path to mkimage(1) command.

OUT
	}

	exit $status;
}

sub create_source($$)
{
	my ($conf, $out) = @_;

	my $parser = load_parser($conf);

	my $fh;
	if ($out) {
		$fh = FileHandle->new($out, O_WRONLY|O_CREAT|O_TRUNC, 0644)
			or die "open($out) failed: $!\n";
		push(@UNLINK, $out) if ($DO_UNLINK);
	}
	else {
		$fh = \*STDOUT;
	}

	$parser->output($fh);
}

sub relocate_device($$)
{
	my ($vmunix, $mach) = @_;

	push(@UNLINK, $vmunix) if ($DO_UNLINK);

	my $kern = load_kern_handle($vmunix);
	$kern->relocate();
}

sub create_image(%)
{
	my (%args) = @_;

	my $parser = load_parser($args{conffile});
	my $mach = $ENV{MACH};
	my $class = "XRamConf::Image::$mach";
	my $load = "require $class; import $class;";
	eval $load;
	if ($@) {
		my $err = "$@";

		chomp($err);
		die "Can't find $mach specific image constructor:\n$err\n";
	}

	if ($DO_UNLINK) {
		push(@UNLINK, $args{kernel}, $args{infofile});

		my $unified = $args{unified};
		push(@UNLINK, $unified) if ($unified);
	}
	my $img = $class->new($args{vmunix}, $parser);
	$img->output(%args);
}

sub update_devlink($$)
{
	my ($conf, $root) = @_;

	$root =~ s,/+$,,g;

	die "Root directory is not found: $root\n" unless (-d $root);
	my $parser = load_parser($conf);

	# At first, cleanup xramdev links.
	my $devdir = $root . XRAMDEV_DEVDIR;
	die "Failed to remove directory: $devdir: $!\n"
		if (!rmtree($devdir) && $! != ENOENT);

	# Create xramdev directory.
	mkdir($devdir) or die "mkdir($devdir) failed: $!\n";

	# Create xramfs device links.
	my $count = $parser->getDeviceCount();
	for (my $index = 0; $index < $count; $index++) {
		my $list = $parser->getDevicePath($index);
		foreach my $l (@$list) {
			my $entity = $l->{entity};
			my $link = $l->{link};
			my $ln = $root . $link;
			symlink($entity, $ln) or
				die "symlink($entity, $ln) failed: $!\n";
		}
	}

	$parser->devlinkImpl($root);
}

sub dump_infofile($)
{
	my ($file) = @_;

	my $fh = FileHandle->new($file) or die "open($file) failed: $!\n";
	binmode($fh);

	require XRamConf::Struct::WbInfo;
	import XRamConf::Struct::WbInfo;

	my $wbinfo = XRamConf::Struct::WbInfo->new();
	my $sb = stat($fh) or die "stat($file) failed: $!\n";
	my $size = $sb->size;

	my $raw;
	my $nbytes = sysread($fh, $raw, $size);
	die "read($file) failed: $!\n" unless (defined($nbytes));
	$wbinfo->decode($raw);

	my $out = \*STDOUT;
	$out->print("\n*** Warm Boot Information: $file\n\n");
	$wbinfo->print($out);
}

sub dump_index($)
{
	my ($vmunix) = @_;

	my $kern = load_kern_handle($vmunix);
	$kern->dumpIndex();
}

sub load_parser($)
{
	my ($conf) = @_;

	my $mach = $ENV{MACH};
	my $class = "XRamConf::Parser::$mach";
	my $load = "require $class; import $class;";
	eval $load;
	if ($@) {
		my $err = "$@";

		chomp($err);
		die "Can't find $mach specific parser class:\n$err\n";
	}

	return $class->new($conf);
}

sub load_kern_handle($)
{
	my ($vmunix) = @_;

	my $mach = $ENV{MACH};
	my $class = "XRamConf::Kernel::$mach";
	my $load = "require $class; import $class;";
	eval $load;
	if ($@) {
		my $err = "$@";

		chomp($err);
		die "Can't find class to manipulate kernel for $mach:\n$err\n";
	}

	return $class->new($vmunix);
}
EOF
