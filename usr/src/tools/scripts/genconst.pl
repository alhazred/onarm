#!/usr/bin/perl

#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright (c) 2006-2007 NEC Corporation
# All rights reserved.
#

=head1 NAME

I<genconst> - Generate header for assembler source

=head1 SYNOPSIS

B<genconst> [options] I<template_file> I<C_compiler> I<CFLAGS> ...

=head1 DESCRIPTION

I<genconst> is useful to generates header file on the cross compilation
environment. It reads templates from file specified by I<template_file>,
and generate header file that contains definitions of constants in
C preprocessor format (#define). It can be included safely from assembler
source.

I<C_compiler> must be a C compiler path that can generate ELF object
for target platform. Rest of arguments are treated as flags for
I<C_compiler>.

Note that I<genconst> uses I<nm> command in Solaris distribution,
not GNU binutils version. If GNU binutils is installed in your build
environment, you may want to use B<-n> option and specify path to
Solaris I<nm>.

=head1 OPTIONS

The following options are supported:

=over 4

=item B<-o>|B<--output>

Specify output filename.
If omitted, results will be dumped to standard output.

=item B<-a>|B<--append>

Append results at the end of output file.
If omitted, I<genconst> will overwrite output file with resuls.

This option will be ignored if B<-o> option is not specified.

=item B<-n>|B<--nm> I<nm_path>

Specify path to Solaris I<nm> command.
If omitted, it will be derived:

=over 3

=item 1.

If B<NM> environment variable is set, its value is used as I<nm> path.

=item 2.

Searches I<nm> command using B<PATH> environment variable.

=back

=item B<-p>|B<--prefix> I<prefix>

Specify prefix for name of constant.
If omitted, no prefix is appended to constant name.

=item B<-c>|B<--c-suffix>

Dump constants with C constant suffix to deterimne size of constants
explicitly. Currently, this option affects only 64 bit constants.

Note that constants with suffix are treated as unsigned.

=item B<-v>|B<--verbose>

Print verbose messages to stderr.

=item B<-k>|B<--keep>

Keep temporary files generated by B<genconst>.
This option is useful to debug.

=back

=head1 TEMPLATE FORMAT

Tempalte file is treated as C source file.

=over 2

=item -

Other header file can be included using "#include" directive.

=item -

"/* ... */" block is treated as comment.

=back

The following macros is provided.
Note that ";" is required at the end of macro.

=over 4

=item B<DEFCONST>(I<constant>)

Define constant.

Name of constant will be I<constant>, and value of I<constant>
will be defined as value.

=item B<DEFCONST_WITH_VALUE>(I<constant>, I<value>)

Define constant specifying value.

Name of constant will be I<constant>, and I<value> will be defined as value.

=back

=head1 EXAMPLES

Let's assume the following situation.

=over 2

=item -

The following value is defined in I<sys/foo.h>:

 #define FOO     1
 #define BAR     (FOO + 0x10)

=item -

Template file contains the following lines:

 #include <sys/foo.h>

 DEFCONST(FOO);
 DEFCONST(BAR);
 DEFCONST_WITH_VALUE(BAZ, FOO + BAR);

=back

The following lines will be generated by I<genconst>.

 #define FOO    0x1
 #define BAR    0x11
 #define BAZ    0x12

=head1 SEE ALSO

I<nm>(1)

=cut

use strict;
use Getopt::Long;
use File::Basename;
use FileHandle;
use POSIX;
use POSIX qw(:sys_wait_h :errno_h);

use vars qw($PROGNAME $NM $VERBOSE $UNLINK $SIZE_BASE $OUTPUT %CONSTANT
	    $PREFIX $USE_SUFFIX);

$PROGNAME = basename($0);
$UNLINK = 1;
$SIZE_BASE = 0x10;

sub usage($);
sub find_program($);
sub check_status($$);
sub run(@);
sub read_from_process($@);
sub parse_symbol_table($);
sub generate_header($$);
sub generate_source($);

# Temporary file object
{
	package TempFile;

	use FileHandle;
	use POSIX;

	sub new {
		my $this = shift;
		my $class = ref($this) || $this;
		my (%args) = (@_);

		if ($args{OPEN}) {
			my $fname = $args{FILENAME};
			my $oflags = O_WRONLY|O_CREAT|O_TRUNC;
			my $fh = FileHandle->new($fname, $oflags, 0644);
			die "Failed to create temporary file($fname): $!\n"
				unless ($fh);
			$args{FH} = $fh;
		}

		my $me = bless \%args, $class;

		return $me;
	}

	sub DESTROY {
		my $me = shift;

		if ($main::UNLINK) {
			my $fname = $me->{FILENAME};
			print STDERR "+ Unlink $fname\n" if ($main::VERBOSE);
			unlink($fname);
		}
	}

	sub print {
		my $me = shift;
		my $fh = $me->{FH};

		$fh->print(@_);
	}

	sub filename {
		my $me = shift;

		return $me->{FILENAME};
	}
}

END {
	if ($? != 0 and $UNLINK and $OUTPUT and -f $OUTPUT) {
		unlink($OUTPUT);
	}
}

MAIN:
{
	Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

	my ($help, $nm, $keep, $append);
	usage(2) unless (GetOptions
			 ('o|output=s'	=> \$OUTPUT,
			  'a|append'	=> \$append,
			  'n|nm=s'	=> \$nm,
			  'v|verbose'	=> \$VERBOSE,
			  'p|prefix=s'	=> \$PREFIX,
			  'c|c-suffix'	=> \$USE_SUFFIX,
			  'k|keep'	=> \$keep,
			  'h|help'	=> \$help));
	usage(0) if ($help);

	$NM = ($nm) ? $nm : find_program('nm');
	$UNLINK = 0 if ($keep);
	my $out;
	if ($OUTPUT) {
		my $oflag = O_WRONLY|O_CREAT;
		if ($append) {
			$oflag |= O_APPEND;
		}
		else {
			$oflag |= O_TRUNC;
		}
		$out = FileHandle->new($OUTPUT, $oflag, 0644) or
			die "Failed to create output($OUTPUT): $!\n";
	}
	else {
		$out = \*STDOUT;
	}

	my ($template, $cc, @cflags) = (@ARGV);
	usage(2) unless ($template and $cc);

	my $src = generate_source($template);
	my $srcname = $src->filename();
	my $objname = basename($srcname, '.c') . '.o';
	my $obj = TempFile->new(FILENAME => $objname);

	# Compile source.
	run($cc, @cflags, '-c', '-o', $objname, $srcname);

	# Parse symbol table, and generate header.
	generate_header($objname, $out);
}

sub usage($)
{
	my ($status) = @_;

	my $out = ($status) ? \*STDERR : \*STDOUT;
	print $out <<OUT;
Usage: $PROGNAME [options] compiler [CFLAGS]
OUT

	unless ($status) {
		print $out <<OUT;

Options:

  -o|--output
      Specify output filename.
      If omitted, results will be dumped to standard output.

  -a|--append
      Append results at the end of output file.
      If omitted, genconst will overwrite output file with resuls.

      This option will be ignored if -o option is not specified.

  -n|--nm nm_path
      Specify path to Solaris nm command.
      If omitted, it will be derived using PATH environment variable.

  -p|--prefix prefix
      Specify prefix for name of constant.
      If omitted, no prefix is appended to constant name.

  -c|--c-suffix
      Dump constants with C constant suffix to deterimne size of constants
      explicitly. Currently, this option affects only 64 bit constants.

  -v|--verbose
      Print verbose messages to stderr.

  -k|--keep
      Keep temporary files generated by genconst.
      This option is useful to debug.

OUT
	}
	exit $status;
}

sub find_program($)
{
	my ($prog) = @_;

	my $name = uc($prog);
	return $ENV{$name} if (defined($ENV{$name}));

	foreach my $dir (split(/:/, $ENV{PATH})) {
		my $p = "$dir/$prog";
		return $p if (-x $p);
	}

	return $prog;
}

sub check_status($$)
{
	my ($cmd, $st) = @_;

	if (WIFEXITED($st)) {
		my $status = WEXITSTATUS($st);
		die "$cmd failed with status $status\n" unless ($status == 0);
	}
	elsif (WSIGNALLED($st)) {
		my $sig = WTERMSIG($st);

		# WCOREDUMP isn't a POSIX macro, do it the non-portable way.
		if ($st & 0x80) {
			die "$cmd failed with signal $sig (core dumped)\n";
		}
		else {
			die "$cmd failed with signal $sig\n";
		}
	}
	else {
		my $msg = sprintf("%s failed: status = 0x%08x", $cmd, $st);
		die "$msg\n";
	}
}

sub run(@)
{
	my (@argv) = @_;
	my $st;

	print STDERR "+ @argv\n" if ($VERBOSE);

	my $status = system(@argv);
	if ($status == -1) {
		die "Failed to execute $argv[0]: $!\n";
	}
	check_status($argv[0], $status);
}

sub read_from_process($@)
{
	my ($handler, @argv) = @_;

	print STDERR "+ @argv\n" if ($VERBOSE);

	my ($rh, $wh) = FileHandle::pipe;
	my $pid = fork();
	if (!defined($pid)) {
		die "fork() failed: $!\n";
	}
	elsif ($pid == 0) {
		undef $rh;
		$wh->autoflush(1);
		POSIX::dup2($wh->fileno(), STDOUT->fileno());

		exec(@argv);
		die "exec(@argv) failed: $!\n";
	}

	undef $wh;
	while (<$rh>) {
		&$handler($_);
	}

	my $ret;
	do {
		$ret = waitpid($pid, 0);
	} while ($ret == -1 and $! == EINTR);
	die "waitpid() failed: $!\n" if ($ret == -1);

	check_status($argv[0], $?);
}

sub parse_symbol_table($)
{
	my ($line) = @_;

	chomp($line);
	my (@col) = split(/\s*\|\s*/, $line);
	return unless (@col == 8 and $col[3] eq 'OBJT' and
		       $col[4] eq 'GLOB' and $col[6] eq 'COMMON');
	if ($col[7] =~ /^const_(q[0-3]|sz)_(.+)$/) {
		my ($part, $name) = ($1, $2);

		my $ent = $CONSTANT{$name};
		unless ($ent) {
			$ent = {};
			$CONSTANT{$name} = $ent;
		}
		my $value = oct($col[2]);
		$value -= $SIZE_BASE if ($part ne 'sz');
		$ent->{$part} = $value;
	}
}

sub generate_header($$)
{
	my ($objname, $out) = @_;

	# Constant values are dumped as the size of byte array named
	# as "const_(hi|lo)_XXX". So we can derive constant values
	# from symbol table using nm command.
	read_from_process(\&parse_symbol_table, $NM, '-x', $objname);

	foreach my $name (sort keys(%CONSTANT)) {
		my $ent = $CONSTANT{$name};
		my $q0 = $ent->{q0};
		my $q1 = $ent->{q1};
		my $q2 = $ent->{q2};
		my $q3 = $ent->{q3};
		my $sz = $ent->{sz};

		my $v = ($q0 << 48) | ($q1 << 32) | ($q2 << 16) | $q3;
		if ($sz < 8) {
			my $mask = (1 << ($sz << 3)) - 1;
			$v &= $mask;
		}
		$name = $PREFIX . $name if ($PREFIX);
		my $suffix = ($USE_SUFFIX and $sz == 8) ? "ULL" : "";
		my $value = sprintf("0x%llx%s", $v, $suffix);
		$out->print(<<OUT);
#define	$name	$value
OUT
	}
}

sub generate_source($)
{
	my ($template) = @_;

	my $tf = FileHandle->new($template) or
		die "Failed to open template($template): $!\n";
	my $fname = "genconst_tmp_$$.c";
	my $f = TempFile->new(FILENAME => $fname, OPEN => 1);

	print STDERR "+ Generate temporary source as $fname\n" if ($VERBOSE);

	# Define builtin macros.
	$f->print(<<OUT);
/*
 * genconst dumps constant value as symbol size.
 * So this constant is required to avoid compile error when the constant
 * value is zero.
 */
#define	_DEFCONST_BASE	$SIZE_BASE

/*
 * Define byte array whose size is the specified value.
 * genconst dumps constant value as byte array size.
 */
#define	_DEFCONST_DEFINE(array, value)		\\
	char const_##array [(value) + _DEFCONST_BASE]

#define	_DEFCONST_SIZE_DEFINE(array, value)	\\
	char const_##array [sizeof(value)]

#define	_Q0MASK		0xffff000000000000ULL
#define	_Q1MASK		0x0000ffff00000000ULL
#define	_Q2MASK		0x00000000ffff0000ULL
#define	_Q3MASK		0x000000000000ffffULL

#define	_DEFCONST_Q0(value)	(((value) & _Q0MASK) >> 48)
#define	_DEFCONST_Q1(value)	(((value) & _Q1MASK) >> 32)
#define	_DEFCONST_Q2(value)	(((value) & _Q2MASK) >> 16)
#define	_DEFCONST_Q3(value)	((value) & _Q3MASK)

/*
 * DEFCONST_WITH_VALUE(constant, value)
 *	Define constant specifying value.
 */
#define	DEFCONST_WITH_VALUE(constant, value)				\\
	_DEFCONST_DEFINE(q0_##constant, _DEFCONST_Q0(value));		\\
	_DEFCONST_DEFINE(q1_##constant, _DEFCONST_Q1(value));		\\
	_DEFCONST_DEFINE(q2_##constant, _DEFCONST_Q2(value));		\\
	_DEFCONST_DEFINE(q3_##constant, _DEFCONST_Q3(value));		\\
	_DEFCONST_SIZE_DEFINE(sz_##constant, value)

/*
 * DEFCONST(constant)
 *	Define constant.
 */
#define	DEFCONST(constant)						\\
	_DEFCONST_DEFINE(q0_##constant, _DEFCONST_Q0(constant));	\\
	_DEFCONST_DEFINE(q1_##constant, _DEFCONST_Q1(constant));	\\
	_DEFCONST_DEFINE(q2_##constant, _DEFCONST_Q2(constant));	\\
	_DEFCONST_DEFINE(q3_##constant, _DEFCONST_Q3(constant));	\\
	_DEFCONST_SIZE_DEFINE(sz_##constant, constant)

/*
 * Templates.
 */
OUT

	# Add template.
	while (<$tf>) {
		$f->print($_);
	}

	return $f;
}
