#!/usr/bin/perl

#
# CDDL HEADER START
#
# The contents of this file are subject to the terms of the
# Common Development and Distribution License (the "License").
# You may not use this file except in compliance with the License.
#
# You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
# or http://www.opensolaris.org/os/licensing.
# See the License for the specific language governing permissions
# and limitations under the License.
#
# When distributing Covered Code, include this CDDL HEADER in each
# file and include the License file at usr/src/OPENSOLARIS.LICENSE.
# If applicable, add the following below this CDDL HEADER, with the
# fields enclosed by brackets "[]" replaced with your own identifying
# information: Portions Copyright [yyyy] [name of copyright owner]
#
# CDDL HEADER END
#

#
# Copyright (c) 2007-2009 NEC Corporation
# All rights reserved.
#

=head1 NAME

I<xheader> - Generate header for cross compile environment

=head1 SYNOPSIS

B<xheader> [options] I<template-file> I<C-compiler> I<CFLAGS> ...

=head1 DESCRIPTION

I<xheader> generates C header file that defines data structure used to
compile binary for cross environment. It reads definitions of data structure
from file specified by I<template-file>, and generates definitions for
cross compile environment.

I<C-compiler> must be a C compiler path that can generate ELF object
for target platform. Rest of arguments are treated as flags for
I<C-compiler>.

I<xheader> also generates macro to access data structure for cross environment.
You should use B<XENV> macro to access cross environment data.
See EXAMPLES section for more details.

=head1 OPTIONS

The following options are supported:

=over 4

=item B<-o>|B<--output>

Specify output filename.
If omitted, results will be dumped to standard output.

=item B<-a>|B<--append>

Append results at the end of output file.
If omitted, I<xheader> will overwrite output file with resuls.

This option will be ignored if B<-o> option is not specified.

=item B<-p>|B<--prefix> I<prefix>

Specify prefix for name of data structure.
If omitted, "__x_" is used as prefix.

For example, "struct data1" will be dumped as "struct xdata1" when prefix
is "x".

=item B<-x>|B<--crossenv> I<constant-name>

Specify name of cpp constant that determines whether cross compile environment
is activated or not. If omitted, "CROSS_COMPILE" is used.

This option is useful to use generated definitions on both cross and native
environment.

=item B<-m>|B<--macro> I<macro-name>

Specify name of wrapper macro to refer data types.
If omitted, "XENV" is used.

=item B<-d>|B<--ctfdump> I<ctfdump-path>

Specify path to I<ctfdump> command.
If omitted, it will be derived:

=over 3

=item 1.

If B<CTFDUMP> environment variable is set, its value is used as I<ctfdump>
path.

=item 2.

Searches I<ctfdump> command using B<PATH> environment variable.

=back

=item B<-r>|B<--ctfconvert> I<ctfconvert-path>

Specify path to I<ctfconvert> command.
If ommited, it will be derived just like I<ctfdump> command path.

=item B<-v>|B<--verbose>

Print verbose messages to stderr.

=item B<-k>|B<--keep>

Keep temporary files generated by B<xheader>.
This option is useful to debug.

=back

=head1 TEMPLATE FORMAT

The format of tempalte file is very similar to C source code.

=over 2

=item -

Other header file can be included using "#include" directive.

=item -

"/* ... */" block is treated as comment.

=back

Name of data structure used for cross compile must be described in one line
following "DEFINE:" keyword. Note that ";" is required at the end of macro.

  DEFINE:struct data1;
  DEFINE:data2_t;

=head1 EXAMPLES

Let's assume the following situation.

=over 2

=item -

The following data structures are defined in I<sys/foo.h>:

 #include <inttypes.h>

 typedef struct data1 {
         uint32_t    d_member1;
         uint8_t     *d_member2;  
 } data1_t;

=back

The following template should be passed to I<xheader>.

 #include <sys/foo.h>

 DEFINE:data1_t;

You can access data1_t like this:

  XENV(data1_t) data;
  struct XENV(data1) d;

  data->d_member = 0;

B<XENV>() macro will expand name of data structure.
If cpp constant name specified to B<-x> option is defined, B<XENV>() macro
will convert data structure name into name for cross environment.
If not defined, retult of B<XENV>() macro will be the same as its argument.

Note that you can change name of macro, B<XENV>(), by specifying B<-m>.

=head1 NOTES

= over 2

=item -

Currently, I<xheader> requires that the pointer size on the target system
is the same as the host system.

=item -

float and double will be dumped as integer to keep offset of
structure member.

=head1 SEE ALSO

I<ctfdump>(1), I<ctfconvert>(1)

=cut

use strict;
use Getopt::Long;
use File::Basename;
use FileHandle;
use POSIX;
use POSIX qw(:sys_wait_h :errno_h);

use vars qw($PROGNAME $CTFDUMP $CTFCONVERT $XENV $VERBOSE $UNLINK $OUTPUT
	    @TYPEDEFS $CURBLOCK $PREFIX $PTRSIZE_NAME $PTRSIZE @HEADERS
	    @FORWARD $MACRO %DATATYPE %VARTYPE $DUMMY_NAME @REQUIRED);

$PROGNAME = basename($0);
$UNLINK = 1;
$PREFIX = '__x_';
$PTRSIZE_NAME = '__xheader_ptr_size';
$DUMMY_NAME = 'dummy';
$XENV = 'CROSS_COMPILE';
$MACRO = 'XENV';

sub usage($);
sub find_program($);
sub check_status($$);
sub run(@);
sub read_from_process($@);
sub generate_source($);
sub parse_ctf_type($);
sub parse_ctf_data($);
sub generate_header($$);
sub roundup($$);
sub howmany($$);
sub print_required($);

# Base class for CTF data type.
{
	package CTFType;

	use strict;
	use Carp;

	use constant	ANON_NAME	=> '(anon)';

	sub new
	{
		my $this = shift;
		my $class = ref($this) || $this;
		my ($index) = @_;

		my $me = {INDEX => $index};
		return bless $me, $class;
	}

	sub getName
	{
		my $me = shift;
		my ($org) = @_;

		return ($org) ? $me->{ORGNAME} : $me->{NAME};
	}

	sub typeName
	{
		my $me = shift;

		my $name = ref($me);
		$name =~ s/^CTFType:://;
		return lc($name);
	}

	sub parse
	{
		confess "Must be overriden.";
	}

	sub getType
	{
		confess "Must be overriden.";
	}

	sub getSize
	{
		confess "Must be overriden.";
	}

	sub define
	{
	}

	sub checkDumped
	{
		my $me = shift;

		my $ret = $me->{DUMPED};
		$me->{DUMPED} = 1;
		return $ret;
	}

	sub isBlock
	{
		return undef;
	}

	sub isAnonymous
	{
		my $me = shift;

		return $me->{ORGNAME} eq $me->ANON_NAME;
	}

	sub declare
	{
		my $me = shift;
		my ($name, $depth) = @_;

		return $me->getType($depth) . ' ' . $name;
	}

	sub forward
	{
		my $me = shift;

		return $me->define();
	}

	sub needForward
	{
		return undef;
	}

	sub dumpForward
	{
	}

	sub pointerReference
	{
		my $me = shift;
		my ($depth, $name, $refcnt) = @_;

		my $ret = $me->getType($depth);
		my $ast = '*' x $refcnt;
		$ret .= ' ' . $ast;
		$ret .= $name if ($name);
		return $ret;
	}

	sub composeArray
	{
		my $me = shift;
		my ($depth, $name, $dim, $ptrref, $typedef) = @_;

		my $ret = $me->getType($depth);
		my $ast = '*' x $ptrref;
		$ret .= ' ' . $ast;
		$ret .= $name if ($name);
		$ret .= ' ' . $typedef if ($typedef);
		foreach my $nelem (@$dim) {
			$ret .= '[' . $nelem . ']';
		}
		return $ret;
	}

	sub defineType
	{
		my $me = shift;
		my ($depth, $name, $ptrref) = @_;

		my $type = $me->getType($depth);
		my $ast = '*' x $ptrref;
		return "typedef $type $ast $name";
	}

	sub getReference
	{
		return undef;
	}

	sub isEntityRequired
	{
		return undef;
	}
}

{
	package CTFType::INTEGER;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~
		    s/^(.+)\s+encoding=(.+) offset=(\d+) bits=(\d+)$//) {
			$me->{NAME} = $me->{ORGNAME} = $1;
			$me->{ENCODING} = $2;
			$me->{BITS} = $4;
		}
		else {
			my $nm = $me->typeName();
			die "Unknown $nm property: $line\n";
		}
	}

	sub validType
	{
		my $me = shift;
		my ($bits) = @_;

		return ($bits == 8 || $bits == 16 || $bits == 32 ||
			$bits == 64);
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		my $type = $me->{TYPE};
		unless ($type) {
			use integer;

			my $bits = $me->{BITS};
			if ($bits == 0) {
				$type = 'void';
			}
			else {
				if ($me->validType($bits)) {
					$type = 'int' . $me->{BITS} . '_t';
				}
				else {
					$type = ($bits > 32)
						? 'int64_t' : 'int32_t';
				}
				unless ($me->{ENCODING} =~ /SIGNED/) {
					$type = 'u' . $type;
				}
			}
			$me->{TYPE} = $type;
		}
		return "\t" x $depth . $type;
	}

	sub getSize
	{
		my $me = shift;

		return $me->{BITS};
	}

	sub declare
	{
		my $me = shift;
		my ($name, $depth) = @_;

		use integer;

		my $bits = $me->{BITS};
		my $ret = $me->getType($depth) . ' ' . $name;
		unless ($me->validType($bits)) {
			$ret .= ':' . $bits;
		}
		return $ret;
	}

	sub needForward
	{
		return 1;
	}
}

{
	package CTFType::FLOAT;

	use strict;
	use Carp;
	use vars qw(@ISA);

	@ISA = qw(CTFType::INTEGER);

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		my $type = $me->{TYPE};
		unless ($type) {
			use integer;

			my $bits = $me->{BITS};
			if ($bits <= 64) {
				$type = $me->SUPER::getType($depth);
			}
			else {
				confess "Unsupported float bits: $bits\n";
			}
			$me->{TYPE} = $type;
		}
		return "\t" x $depth . $type;
	}
}

{
	package CTFType::TYPEDEF;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~ s/^(.+)\s+refers to (\d+)$//) {
			my $orgname = $1;
			my $name = $main::PREFIX . $orgname;
			$me->{ORGNAME} = $orgname;
			$me->{NAME} = $name;
			$me->{TYPE} = $name;
			$me->{REF} = $2;
		}
		else {
			die "Unknown TYPEDEF property: $line\n";
		}
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		return "\t" x $depth . $me->{TYPE};
	}

	sub define
	{
		my $me = shift;

		return if ($me->checkDumped());

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->defineType(-1, $me->{NAME}, 0);
	}

	sub getSize
	{
		my $me = shift;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->getSize();
	}

	sub needForward
	{
		return 1;
	}

	sub forward
	{
		my $me = shift;

		my $ret;
		unless ($me->{FW_DUMPED}) {
			$me->{FW_DUMPED} = 1;
			my $ref = $main::TYPEDEFS[$me->{REF}];
			if ($ref->needForward()) {
				my $f = $ref->forward();
				$ret = $me->define();
				if ($f) {
					if ($ret) {
						$ret = "$f;\n$ret";
					}
					else {
						$ret = $f;
					}
				}
			}
		}
		return $ret;
	}

	sub getReference
	{
		my $me = shift;

		my $r = $me->{REF};
		$r = $main::TYPEDEFS[$r] if ($r);
		return $r;
	}

	sub isEntityRequired
	{
		my $me = shift;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->isEntityRequired();
	}
}

{
	package CTFType::POINTER;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~ s/^(.+)\s+refers to (\d+)$//) {
			$me->{ORGNAME} = $1;
			$me->{NAME} = $main::PREFIX . $1;
			$me->{REF} = $2;
		}
		else {
			die "Unknown POINTER property: $line\n";
		}
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->pointerReference($depth, undef, 1);
	}

	sub getSize
	{
		return $main::PTRSIZE * 8;
	}

	sub declare
	{
		my $me = shift;
		my ($name, $depth) = @_;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->pointerReference($depth, $name, 1);
	}

	sub pointerReference
	{
		my $me = shift;
		my ($depth, $name, $refcnt) = @_;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->pointerReference($depth, $name, $refcnt + 1);
	}

	sub composeArray
	{
		my $me = shift;
		my ($depth, $name, $dim, $ptrref, $typedef) = @_;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->composeArray($depth, $name, $dim, $ptrref + 1,
					  $typedef);
	}

	sub defineType
	{
		my $me = shift;
		my ($depth, $name, $ptrref) = @_;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->defineType($depth, $name, $ptrref + 1);
	}

	sub forward
	{
		my $me = shift;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->forward();
	}

	sub needForward
	{
		return 1;
	}

	sub getReference
	{
		my $me = shift;

		my $r = $me->{REF};
		$r = $main::TYPEDEFS[$r] if ($r);
		return $r;
	}
}

{
	package CTFType::Modifier;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~ s/^(.+)\s+refers to (\d+)$//) {
			$me->{REF} = $2;
		}
		else {
			my $name = uc($me->modifier());
			die "Unknown $name property: $line\n";
		}
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		my $type = $me->{TYPE};
		unless ($type) {
			my $ref = $main::TYPEDEFS[$me->{REF}];
			$type = $me->modifier() . ' ' . $ref->getType();
			$me->{TYPE} = $type;
		}
		return "\t" x $depth . $type;
	}

	sub declare
	{
		my $me = shift;
		my ($name, $depth) = @_;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		my $ret = $ref->declare($name, 0);
		my $indent = "\t" x $depth;
		$ret = sprintf("%s%s %s", $indent, $me->modifier(), $ret);
		return $ret;
	}

	sub getSize
	{
		my $me = shift;

		my $ref = $main::TYPEDEFS[$me->{REF}];
		return $ref->getSize();
	}

	sub modifier
	{
		die "Must be overriden.\n";
	}

	sub getReference
	{
		my $me = shift;

		my $r = $me->{REF};
		$r = $main::TYPEDEFS[$r] if ($r);
		return $r;
	}
}

{
	package CTFType::CONST;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType::Modifier);

	sub modifier
	{
		return 'const';
	}
}

{
	package CTFType::VOLATILE;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType::Modifier);

	sub modifier
	{
		return 'volatile';
	}
}

{
	package CTFType::FUNCTION;

	use strict;
	use Carp;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~
		    s/^(.+)\s+returns:\s+(\d+)\s+args:\s+\(([\d, ]*)\)$//) {
			my (@args) = split(/\s*,\s*/, $3);
			$me->{ARGS} = \@args;
			$me->{RETURN} = $2;
		}
		else {
			die "Unknown FUNCTION property: $line\n";
		}
	}

	sub getArgs
	{
		my $me = shift;

		my @args;
		foreach my $a (@{$me->{ARGS}}) {
			my $ref = $main::TYPEDEFS[$a];
			push(@args, $ref->getType());
		}
		my $ret = (@args) ? join(', ', @args) : '';
		return "($ret)";
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		return $me->pointerReference($depth, undef, 0);
	}

	sub getSize
	{
		confess "Unexpected call for FUNCTION->getSize()\n";
	}

	sub declare
	{
		my $me = shift;
		my ($name, $depth) = @_;

		return $me->pointerReference($depth, $name, 0);
	}

	sub pointerReference
	{
		my $me = shift;
		my ($depth, $name, $refcnt) = @_;

		my $retp = $main::TYPEDEFS[$me->{RETURN}];
		my $type = $retp->getType($depth);
		my $args = $me->getArgs();
		my $ast = '*' x $refcnt;
		return sprintf("%s (%s%s)%s", $type, $ast, $name, $args);
	}

	sub composeArray
	{
		my $me = shift;
		my ($depth, $name, $dim, $ptrref, $typedef) = @_;

		my $retp = $main::TYPEDEFS[$me->{RETURN}];
		my $type = $retp->getType($depth);
		my $args = $me->getArgs();
		my $ast = '*' x $ptrref;
		my $nm = $ast . (($typedef) ? $typedef : $name);
		foreach my $nelem (@$dim) {
			$nm .= '[' . $nelem . ']';
		}
		return sprintf("%s (%s)%s", $type, $nm, $args);
	}

	sub defineType
	{
		my $me = shift;
		my ($depth, $name, $ptrref) = @_;

		my $retp = $main::TYPEDEFS[$me->{RETURN}];
		my $type = $retp->getType($depth);
		my $args = $me->getArgs();
		my $ast = '*' x $ptrref;
		my $nm = $ast . $name;
		return sprintf("typedef %s (%s)%s", $type, $nm, $args);
	}

	sub forward
	{
		my $me = shift;

		my @ret;
		foreach my $a (@{$me->{ARGS}}) {
			my $ref = $main::TYPEDEFS[$a];
			if ($ref->needForward()) {
				my $f = $ref->forward();
				push(@ret, $f) if ($f);
			}
		}
		return join(";\n", @ret);
	}
}

{
	package CTFType::ARRAY;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~ /content: (\d+) index: (\d+) nelems: (\d+)$/) {
			$me->{CONTENT} = $1;
			$me->{NELEMS} = $3;
		}
		else {
			die "Unknown ARRAY property: $line\n";
		}
	}

	sub declare
	{
		my $me = shift;
		my ($name, $depth) = @_;

		my $ref = $main::TYPEDEFS[$me->{CONTENT}];
		return $ref->composeArray($depth, $name, [$me->{NELEMS}]);
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		my $type = $me->{TYPE};
		unless ($type) {
			my $ref = $main::TYPEDEFS[$me->{CONTENT}];
			$type = $ref->composeArray(0, undef, [$me->{NELEMS}]);
			$me->{TYPE} = $type;
		}
		return "\t" x $depth . $type;
	}

	sub composeArray
	{
		my $me = shift;
		my ($depth, $name, $dim, $ptrref, $typedef) = @_;

		push(@$dim, $me->{NELEMS});
		my $ref = $main::TYPEDEFS[$me->{CONTENT}];
		return $ref->composeArray($depth, $name, $dim, $ptrref,
					  $typedef);
	}

	sub getSize
	{
		my $me = shift;
		
		my $ref = $main::TYPEDEFS[$me->{CONTENT}];
		return $ref->getSize() * $me->{NELEMS};
	}

	sub defineType
	{
		my $me = shift;
		my ($depth, $name, $ptrref) = @_;

		my $def = $me->composeArray($depth, undef, [], $ptrref, $name);

		return "typedef $def";
	}
}

{
	package CTFType::ENUM;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub new
	{
		my $this = shift;
		my $class = ref($this) || $this;

		my $me = $class->SUPER::new(@_);
		$me->{MEMBER} = [];
		return $me;
	}

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		my $name = $main::PREFIX . $line;
		$me->{ORGNAME} = $line;
		$me->{NAME} = $name;
		$me->{TYPE} = "enum $name";
	}

	sub addMember
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~ /^\s*(\S+)\s+=\s+(-?\d+)$/) {
			my $member = [$1, $2];
			push(@{$me->{MEMBER}}, $member);
		}
		else {
			die "Unknown ENUM member format: $line\n";
		}
	}

	sub checkDumped
	{
		my $me = shift;

		return undef if ($me->isAnonymous());
		return $me->SUPER::checkDumped();
	}

	sub define
	{
		my $me = shift;
		my ($depth) = @_;

		my $anon = $me->isAnonymous();
		return if ($anon and !$depth);
		$depth = 0 if ($depth < 0);

		return if ($me->checkDumped());
		my $indent = "\t" x $depth;
		my $bindent = $indent . "\t";
		my $name = ($anon) ? $indent . 'enum' : $me->getType($depth);
		my $ret = $name . " {\n";
		my (@member);
		foreach my $m (@{$me->{MEMBER}}) {
			my ($nm, $val) = @$m;

			$nm = $main::PREFIX . $nm;
			push(@member, "$bindent$nm = $val");
		}
		$ret .= join(",\n", @member) . "\n";
		$ret .= $indent . '}';
		return $ret;
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		if ($me->isAnonymous()) {
			return $me->define($depth);
		}
		else {
			return "\t" x $depth . $me->{TYPE};
		}
	}

	sub getSize
	{
		my $me = shift;

		return 32;
	}

	sub isBlock
	{
		return 1;
	}

	sub forward
	{
		my $me = shift;

		return if ($me->isAnonymous());
		return $me->define();
	}

	sub needForward
	{
		return 1;
	}
}

{
	package CTFType::STRUCT;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub new
	{
		my $this = shift;
		my $class = ref($this) || $this;

		my $me = $class->SUPER::new(@_);
		$me->{MEMBER} = [];
		$me->{REFS} = [];
		$me->{PAD} = 0;
		return $me;
	}

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~ s/^(\S+)\s+\((\d+)\s+bytes\)$//) {
			my $orgname = $1;
			my $name = $main::PREFIX . $orgname;
			my $size = $2;
			if ($1 eq $main::PTRSIZE_NAME) {
				$main::PTRSIZE = $size;
			}
			$me->{ORGNAME} = $orgname;
			$me->{NAME} = $name;
			$me->{SIZE} = $size;
			$me->{TYPE} = $me->typeName() . " $name";
		}
		else {
			my $nm = uc($me->typeName());
			die "Unknown $nm property: $line\n";
		}
	}

	sub addMember
	{
		my $me = shift;
		my ($line) = @_;

		if ($line =~ /^\s*(\S+) type=(\d+) off=(\d+)$/) {
			my $member = {NAME => $1, TYPE => $2, OFFSET => $3};
			push(@{$me->{MEMBER}}, $member);
			push(@{$me->{REFS}}, $2);
		}
		else {
			my $nm = $me->typeName();
			die "Unknown $nm member format: $line\n";
		}
	}

	sub padding
	{
		my $me = shift;
		my ($size, $depth) = @_;

		use integer;

		my $indent = "\t" x $depth;
		my $ret;
		my $bits = $size % 8;
		$size /= 8;
		my $pad = $me->{PAD};
		if ($bits) {
			$ret .= "${indent}uint8_t pad${pad}:${bits};\n";
			$pad++;
		}

		$ret .= "${indent}uint8_t pad${pad}[$size];\n" if ($size);
		$me->{PAD} = $pad + 1;
		return $ret;
	}

	sub dumpForward
	{
		my $me = shift;

		my $ret;
		foreach my $m (@{$me->{MEMBER}}) {
			my $ref = $main::TYPEDEFS[$m->{TYPE}];
			my $fw = $ref->forward();
			$ret .= "$fw;\n" if ($fw);
		}
		return $ret;
	}

	sub define
	{
		my $me = shift;
		my ($depth) = @_;

		return if ($me->{ORGNAME} eq $main::PTRSIZE_NAME);
		my $anon = $me->isAnonymous();
		return if ($anon and !$depth);
		$depth = 0 if ($depth < 0);

		return if (!$anon and $me->checkDumped());

		my $ret;

		# Check whether the type of member must be defined preceded
		# by this struct.
		if ($depth == 0) {
			foreach my $m (@{$me->{MEMBER}}) {
				my $t = $m->{TYPE};
				my $ref = $main::TYPEDEFS[$t];

				if (!$ref->isAnonymous() and
				    $ref->isEntityRequired()) {
					# This type must be defined here.
					my $prev;
					while ($ref) {
						$prev = $ref;
						$ref = $ref->getReference();
					}
					$ref = $prev unless ($ref);
					my $def = $ref->define($depth);
					push(@main::REQUIRED, $def) if ($def);
				}
			}
		}

		my $curoff = 0;
		my $indent = "\t" x $depth;
		my $name = ($anon) ? $indent . 'struct'
			: $me->getType($depth);
		$ret .= $name . " {\n";
		foreach my $m (@{$me->{MEMBER}}) {
			my ($nm, $t, $off) = ($m->{NAME}, $m->{TYPE},
					      $m->{OFFSET});

			my $diff = $off - $curoff;
			if ($diff > 0) {
				my $pad = $me->padding($diff, $depth + 1);
				$ret .= $pad;
			}
			elsif ($diff < 0) {
				die "Invalid offset: $nm: $curoff, $off\n";
			}
			my $ref = $main::TYPEDEFS[$t];
			my $decl = $ref->declare($nm, $depth + 1);
			$ret .= "$decl;\n";
			$curoff = $off + $ref->getSize();
		}
		my $sz = $me->getSize();
		my $diff = $sz - $curoff;
		if ($diff > 0) {
			my $pad = $me->padding($diff, $depth + 1);
			$ret .= $pad;
		}
		elsif ($diff < 0) {
			my $nm = $me->{ORGNAME};
			die "Invalid structure size: $nm: $curoff, $sz\n";
		}
		$ret .= $indent . '}';
		return $ret;
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		if ($me->isAnonymous()) {
			return $me->define($depth);
		}

		return "\t" x $depth . $me->{TYPE};
	}

	sub getSize
	{
		my $me = shift;

		return $me->{SIZE} * 8;
	}

	sub isBlock
	{
		return 1;
	}

	sub forward
	{
		my $me = shift;

		return if ($me->{FW_DUMPED});
		$me->{FW_DUMPED} = 1;

		my $ret;
		if ($me->isAnonymous()) {
			# All types used by member of anonymous struct should
			# be defined here.
			my (@defs);
			foreach my $m (@{$me->{MEMBER}}) {
				my $ref = $main::TYPEDEFS[$m->{TYPE}];
				my $r = $ref;

				while ($r) {
					if ($r->isa("CTFType::STRUCT")) {
						push(@defs, $ref->define());
						last;
					}
					$r = $r->getReference();
				}
			}
			$ret = join(";\n", @defs) if (@defs);
		}
		else {
			$ret = $me->getType();
		}

		return $ret;
	}

	sub needForward
	{
		return 1;
	}

	sub isEntityRequired
	{
		return 1;
	}
}

{
	package CTFType::UNION;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType::STRUCT);

	sub define
	{
		my $me = shift;
		my ($depth) = @_;

		return if ($me->{ORGNAME} eq $main::PTRSIZE_NAME);
		my $anon = $me->isAnonymous();
		return if ($anon and !$depth);
		$depth = 0 if ($depth < 0);

		return if ($me->checkDumped());

		my $indent = "\t" x $depth;
		my $name = ($anon) ? 'union' : $me->getType($depth);
		my $ret = $indent . $name . " {\n";
		foreach my $m (@{$me->{MEMBER}}) {
			my ($nm, $t) = ($m->{NAME}, $m->{TYPE});

			my $ref = $main::TYPEDEFS[$t];
			my $decl = $ref->declare($nm, $depth + 1);
			$ret .= "$decl;\n";
		}
		$ret .= $indent . '}';
		return $ret;
	}
}

{
	package CTFType::FORWARD;

	use strict;
	use vars qw(@ISA);

	@ISA = qw(CTFType);

	sub parse
	{
		my $me = shift;
		my ($line) = @_;

		my $nm = $main::PREFIX . $line;
		$me->{ORGNAME} = $line;
		$me->{NAME} = $nm;
		$me->{TYPE} = "struct $nm";
	}

	sub getType
	{
		my $me = shift;
		my ($depth) = @_;

		return "\t" x $depth . $me->{TYPE};
	}

	sub define
	{
		my $me = shift;

		return if ($me->checkDumped());
		return $me->getType();
	}

	sub getSize
	{
		my $me = shift;

		my $name = $me->{ORGNAME};
		die "Unknown size: $name\n";
	}

	sub needForward
	{
		return 1;
	}
}

# Temporary file object
{
	package TempFile;

	use FileHandle;
	use POSIX;

	sub new {
		my $this = shift;
		my $class = ref($this) || $this;
		my (%args) = (@_);

		if ($args{OPEN}) {
			my $fname = $args{FILENAME};
			my $oflags = O_WRONLY|O_CREAT|O_TRUNC;
			my $fh = FileHandle->new($fname, $oflags, 0644);
			die "Failed to create temporary file($fname): $!\n"
				unless ($fh);
			$args{FH} = $fh;
		}

		my $me = bless \%args, $class;

		return $me;
	}

	sub DESTROY {
		my $me = shift;

		if ($main::UNLINK) {
			my $fname = $me->{FILENAME};
			print STDERR "+ Unlink $fname\n" if ($main::VERBOSE);
			unlink($fname);
		}
	}

	sub print {
		my $me = shift;
		my $fh = $me->{FH};

		$fh->print(@_);
	}

	sub filename {
		my $me = shift;

		return $me->{FILENAME};
	}
}

END {
	if ($? != 0 and $UNLINK and $OUTPUT and -f $OUTPUT) {
		unlink($OUTPUT);
	}
}

MAIN:
{
	Getopt::Long::Configure(qw(no_ignore_case bundling require_order));

	my ($help, $keep, $append, $prefix, $ctfdump, $ctfconvert, $xenv,
	    $macro);
	usage(2) unless (GetOptions
			 ('o|output=s'		=> \$OUTPUT,
			  'a|append'		=> \$append,
			  'p|prefix=s'		=> \$prefix,
			  'x|crossenv=s'	=> \$xenv,
			  'd|ctfdump=s'		=> \$ctfdump,
			  'r|ctfconvert=s'	=> \$ctfconvert,
			  'm|macro=s'		=> \$macro,
			  'v|verbose'		=> \$VERBOSE,
			  'k|keep'		=> \$keep,
			  'h|help'		=> \$help));
	usage(0) if ($help);

	$CTFDUMP = ($ctfdump) ? $ctfdump : find_program('ctfdump');
	$CTFCONVERT = ($ctfconvert) ? $ctfconvert : find_program('ctfconvert');
	$UNLINK = 0 if ($keep);
	$PREFIX = $prefix if ($prefix);
	$XENV = $xenv if ($xenv);
	$MACRO = $macro if ($macro);
	my $out;
	if ($OUTPUT) {
		my $oflag = O_WRONLY|O_CREAT;
		if ($append) {
			$oflag |= O_APPEND;
		}
		else {
			$oflag |= O_TRUNC;
		}
		$out = FileHandle->new($OUTPUT, $oflag, 0644) or
			die "Failed to create output($OUTPUT): $!\n";
	}
	else {
		$out = \*STDOUT;
	}

	my ($template, $cc, @cflags) = (@ARGV);
	usage(2) unless ($template and $cc);

	my $src = generate_source($template);
	my $srcname = $src->filename();
	my $objname = basename($srcname, '.c') . '.o';
	my $obj = TempFile->new(FILENAME => $objname);

	# Compile source.
	run($cc, @cflags, '-c', '-o', $objname, $srcname);

	# Convert debug information into CTF section.
	run($CTFCONVERT, '-i', '-L', 'VERSION', $objname);

	# Parse CTF section and generate header.
	generate_header($objname, $out);
}

sub usage($)
{
	my ($status) = @_;

	my $out = ($status) ? \*STDERR : \*STDOUT;
	print $out <<OUT;
Usage: $PROGNAME [options] compiler [CFLAGS]
OUT

	unless ($status) {
		print $out <<OUT;

Options:

  -o|--output
      Specify output filename.
      If omitted, results will be dumped to standard output.

  -a|--append
      Append results at the end of output file.
      If omitted, xheader will overwrite output file with resuls.

      This option will be ignored if -o option is not specified.

  -p|--prefix prefix
      Specify prefix for name of data structure.
      If omitted, "x" is used as prefix.

  -x|--crossenv constant-name
      Specify name of cpp constant that determines whether cross compile
      environment is activated or not. If omitted, "CROSS_COMPILE" is used.

  -m|--macro macro-name
      Specify name of wrapper macro to refer data types.
      If omitted, "XENV" is used.

  -d|--ctfdump ctfdump-path
      Specify path to ctfdump command.
      If omitted, it will be derived using PATH environment variable.

  -r|--ctfconvert ctfconvert-path
      Specify path to ctfconvert command.
      If omitted, it will be derived using PATH environment variable.

  -v|--verbose
      Print verbose messages to stderr.

  -k|--keep
      Keep temporary files generated by xheader.
      This option is useful to debug.

OUT
	}
	exit $status;
}

sub find_program($)
{
	my ($prog) = @_;

	my $name = uc($prog);
	return $ENV{$name} if (defined($ENV{$name}));

	foreach my $dir (split(/:/, $ENV{PATH})) {
		my $p = "$dir/$prog";
		return $p if (-x $p);
	}

	return $prog;
}

sub check_status($$)
{
	my ($cmd, $st) = @_;

	if (WIFEXITED($st)) {
		my $status = WEXITSTATUS($st);
		die "$cmd failed with status $status\n" unless ($status == 0);
	}
	elsif (WSIGNALLED($st)) {
		my $sig = WTERMSIG($st);

		# WCOREDUMP isn't a POSIX macro, do it the non-portable way.
		if ($st & 0x80) {
			die "$cmd failed with signal $sig (core dumped)\n";
		}
		else {
			die "$cmd failed with signal $sig\n";
		}
	}
	else {
		my $msg = sprintf("%s failed: status = 0x%08x", $cmd, $st);
		die "$msg\n";
	}
}

sub run(@)
{
	my (@argv) = @_;
	my $st;

	print STDERR "+ @argv\n" if ($VERBOSE);

	my $status = system(@argv);
	if ($status == -1) {
		die "Failed to execute $argv[0]: $!\n";
	}
	check_status($argv[0], $status);
}

sub read_from_process($@)
{
	my ($handler, @argv) = @_;

	print STDERR "+ @argv\n" if ($VERBOSE);

	my ($rh, $wh) = FileHandle::pipe;
	my $pid = fork();
	if (!defined($pid)) {
		die "fork() failed: $!\n";
	}
	elsif ($pid == 0) {
		undef $rh;
		$wh->autoflush(1);
		POSIX::dup2($wh->fileno(), STDOUT->fileno());

		exec(@argv);
		die "exec(@argv) failed: $!\n";
	}

	undef $wh;
	while (<$rh>) {
		&$handler($_);
	}

	my $ret;
	do {
		$ret = waitpid($pid, 0);
	} while ($ret == -1 and $! == EINTR);
	die "waitpid() failed: $!\n" if ($ret == -1);

	check_status($argv[0], $?);
}

sub parse_ctf_type($)
{
	my ($line) = @_;

	if ($line =~ /^\s*$/) {
		$CURBLOCK = undef;
	}
	chomp($line);

	my ($index, $class);
	if ($line =~ s/^\s+\[(\d+)\]\s+([A-Z]+)\s+//) {
		$index = $1;
		$class = $2;
	}
	elsif ($line =~ s/^\s+<(\d+)>\s+([A-Z]+)\s+//) {
		$index = $1;
		$class = $2;
	}
	if ($index) {
		my $cl = 'CTFType::' . $class;
		my $type = $cl->new($index);
		$type->parse($line);
		$CURBLOCK = $type if ($type->isBlock());
		$TYPEDEFS[$index] = $type;
		push(@FORWARD, $type) if ($type->needForward());
	}
	elsif ($CURBLOCK) {
		$CURBLOCK->addMember($line);
	}
}

sub parse_ctf_data($)
{
	my ($line) = @_;

	chomp($line);

	if ($line =~ /(\d+)\s+($DUMMY_NAME\d+) /) {
		my $type = $VARTYPE{$2};

		$DATATYPE{$type} = $1;
	}
}

sub generate_header($$)
{
	my ($objname, $out) = @_;

	# Obtain CTF data type ID for the required types.
	read_from_process(\&parse_ctf_data, $CTFDUMP, '-d', $objname);

	# Dump data types using ctfdump.
	read_from_process(\&parse_ctf_type, $CTFDUMP, '-t', $objname);

	# Dump definitions for cross environment.
	my $headdef = '__' . $XENV . '__';
	$out->print(<<OUT);
#ifndef	$headdef
#define	$headdef

#ifdef	__cplusplus
extern "C" {
#endif	/* __cplusplus */

#ifdef	$XENV

/* Definitions for cross compile environment. */

#define	$MACRO(name)	$PREFIX##name

OUT
	# inttypes.h is needed to define INTEGER primitives.
	$out->print("#include <inttypes.h>\n\n");

	# Define pointer size.
	$out->print("#define XPTRSIZE\t" . $PTRSIZE . "\n\n");

	# Dump forward definitions.
	foreach my $f (@FORWARD) {
		my $fw = $f->forward();
		print_required($out);
		$out->print("$fw;\n") if ($fw);
	}

	# Dump data types for cross environment.
	foreach my $type (@TYPEDEFS) {
		if ($type) {
			my $fw = $type->dumpForward();
			print_required($out);
			$out->print("$fw;\n") if ($fw);

			my $def = $type->define();
			print_required($out);
			$out->print("$def;\n") if ($def);
		}
	}

	# Check whether the give type name is a real name or not.
	while (my ($nm, $id) = each(%DATATYPE)) {
		my $type = $TYPEDEFS[$id];
		my $rname = $type->getName(1);
		my $name = $type->getName();
		my $tname = $nm;
		$tname =~ s/^(struct|union|enum)\s*//;

		if ($tname ne $rname) {
			# Data type name doesn't match.
			# The given name should be a cpp macro.
			my $newname = $PREFIX . $tname;

			$out->print(<<OUT);
#define	$newname	$name
OUT
		}
	}

	# Dump definitions for native environment.
	$out->print(<<OUT);

#else	/* !$XENV */

/* Definitions for native compile environment. */

#define	$MACRO(name)	name

OUT
	foreach my $h (@HEADERS) {
		chomp($h);
		$out->print(<<OUT);
$h
OUT
	}

	$out->print(<<OUT);

#endif	/* $XENV */

#ifdef	__cplusplus
}
#endif	/* __cplusplus */

#endif	/* !$headdef */
OUT
}

sub generate_source($)
{
	my ($template) = @_;

	my $tf = FileHandle->new($template) or
		die "Failed to open template($template): $!\n";
	my $fname = "xheader_tmp_$$.c";
	my $f = TempFile->new(FILENAME => $fname, OPEN => 1);

	print STDERR "+ Generate temporary source as $fname\n" if ($VERBOSE);

	# Read templates, and define dummy data.
	my $cnt = 0;
	while (<$tf>) {
		if (/^DEFINE:\s*(.+?)\s*;\s*$/) {
			my $type = $1;
			my $var = $DUMMY_NAME . $cnt;
			
			$VARTYPE{$var} = $type;
			$f->print("$type $var;\n");
			$cnt++;
		}
		else {
			if (/^#\s*include/) {
				push(@HEADERS, $_);
			}
			$f->print($_);
		}
	}

	# Embed dummy data to detect pointer size.
	$f->print(<<OUT);
union $PTRSIZE_NAME {
	void *ptr;
} dummy$PTRSIZE_NAME;
OUT

	return $f;
}

sub howmany($$)
{
	my ($x, $align) = @_;

	use integer;

	return ($x + ($align - 1)) / $align;
}

sub roundup($$)
{
	my ($x, $align) = @_;

	use integer;

	return howmany($x, $align) * $align;
}

sub print_required($)
{
	my ($out) = @_;

	if (@REQUIRED) {
		$out->print(join(";\n", @REQUIRED), ";\n");
		@REQUIRED = ();
	}
}
