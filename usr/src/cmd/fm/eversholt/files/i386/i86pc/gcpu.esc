/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */

/*
 * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#pragma ident	"%Z%%M%	%I%	%E% SMI"

/*
 * eversholt rules for generic x86 MCA
 *
 * Most propogations are generated by preprocessor macros.  The event
 * declarations are deliberately not part of the propogation macros
 * so that we know we have full coverage - propogations defined without
 * events, or events not used in propogations, will produce compiler
 * whinges.
 */

#pragma dictionary "GMCA"

fru motherboard/chip;

asru motherboard/chip/cpu;

/*
 * Ereports for Simple error codes.
 */

#define SMPL_EVENT(leafclass) \
	event ereport.cpu.generic-x86.leafclass@chip/cpu { within(1s) }

SMPL_EVENT(unknown);	
SMPL_EVENT(unclassified);
SMPL_EVENT(microcode_rom_parity);
SMPL_EVENT(external);
SMPL_EVENT(frc);
SMPL_EVENT(internal_timer);
SMPL_EVENT(internal_unclassified);

/*
 * Propogations for all but "external" and "unknown" simple errors.
 * If the error is uncorrected we produce a fault immediately, otherwise
 * we diagnose it to an upset and decalre a fault when the SERD engine
 * trips.
 */

/* Simple fault event */
event fault.cpu.generic-x86.internal@chip/cpu,
    ASRU=motherboard/chip/cpu, FRU=motherboard/chip,
    FITrate=1000;

/* Produced when the correctable engine trips */
event ereport.cpu.generic-x86.simple_trip@chip/cpu { within(1s) };

/* Upset to diagnose corrected events to */
event upset.cpu.generic-x86.simple@chip/cpu
    engine=serd.cpu.generic-x86.simple@chip/cpu;

/* SERD engine for corrected simple errors */
engine serd.cpu.generic-x86.simple@chip/cpu,
	N=3, T=72h, method=persistent,
	trip=ereport.cpu.generic-x86.simple_trip@chip/cpu;

#define	STATUS_UC \
	(payloadprop("error_uncorrected") + 0 == 1)

/* Diagnose corrected events to upsets */
prop upset.cpu.generic-x86.simple@chip/cpu
    { !STATUS_UC } (1)->
    ereport.cpu.generic-x86.microcode_rom_parity@chip/cpu,
    ereport.cpu.generic-x86.internal_timer@chip/cpu,
    ereport.cpu.generic-x86.unclassified@chip/cpu,
    ereport.cpu.generic-x86.internal_unclassified@chip/cpu,
    ereport.cpu.generic-x86.frc@chip/cpu;

/* When the correctable engine trips, diagnose a fault */
prop fault.cpu.generic-x86.internal@chip/cpu (0)->
	ereport.cpu.generic-x86.simple_trip@chip/cpu;

/* Diagnose uncorrected events to faults */
prop fault.cpu.generic-x86.internal@chip/cpu
    { STATUS_UC } (0)->
    ereport.cpu.generic-x86.microcode_rom_parity@chip/cpu,
    ereport.cpu.generic-x86.internal_timer@chip/cpu,
    ereport.cpu.generic-x86.unclassified@chip/cpu,
    ereport.cpu.generic-x86.internal_unclassified@chip/cpu,
    ereport.cpu.generic-x86.frc@chip/cpu;

/*
 * Ereports for Compound error codes.  These are in pairs "foo" and "foo_uc"
 * for the corrected and uncorrected version of each error type.  All are
 * detected at chip/cpu.
 */

#define	CMPND_EVENT(leafclass) \
	event ereport.cpu.generic-x86.leafclass@chip/cpu { within(1s) }; \
	event ereport.cpu.generic-x86.leafclass/**/_uc@chip/cpu { within(1s) }

/*
 * Ereports for Compound error codes - generic memory hierarchy errors
 */
CMPND_EVENT(l0cache);
CMPND_EVENT(l1cache);
CMPND_EVENT(l2cache);
CMPND_EVENT(cache);

/*
 * Ereports for Compound error codes - TLB errors
 */
CMPND_EVENT(l0dtlb);
CMPND_EVENT(l1dtlb);
CMPND_EVENT(l2dtlb);
CMPND_EVENT(dtlb);

CMPND_EVENT(l0itlb);
CMPND_EVENT(l1itlb);
CMPND_EVENT(l2itlb);
CMPND_EVENT(itlb);

CMPND_EVENT(l0tlb);
CMPND_EVENT(l1tlb);
CMPND_EVENT(l2tlb);
CMPND_EVENT(tlb);

/*
 * Ereports for Compound error codes - memory hierarchy errors
 */
CMPND_EVENT(l0dcache);
CMPND_EVENT(l1dcache);
CMPND_EVENT(l2dcache);
CMPND_EVENT(dcache);

CMPND_EVENT(l0icache);
CMPND_EVENT(l1icache);
CMPND_EVENT(l2icache);
CMPND_EVENT(icache);

/*
 * Ereports for Compound error codes - bus and interconnect errors
 */
CMPND_EVENT(bus_interconnect);
CMPND_EVENT(bus_interconnect_memory);
CMPND_EVENT(bus_interconnect_io);

/*
 * Compound error propogations for all but bus_interconnect*.
 *
 * We resist the temptation propogate, for example, a single dcache fault
 * to all ereports mentioning dcache (l0dcache, l1dcache, l2dcache, dcache).
 * Instead we will diagnose a distinct fault for each possible cache level,
 * whether or not current chips have dcaches at all levels.
 *
 * Corrected errors are SERDed and produce a fault when the engine fires;
 * the same fault is diagnosed immediately for a corresponding uncorrected
 * error.
 */

#define	CMPND_FLT_PROP_1(erptleaf, fltleaf, n, t) \
	/* Declare the fault that we can diagnose here */		\
	event fault.cpu.generic-x86.fltleaf@chip/cpu,			\
	    FITrate=1000,						\
	    FRU=motherboard/chip,					\
	    ASRU=motherboard/chip/cpu;					\
									\
	/* Produced when the correctable engine trips */		\
	event ereport.cpu.generic-x86.fltleaf/**/_error@chip/cpu	\
	    { within(1s) };						\
									\
	/* Upset to diagnose corrected events to */			\
	event upset.cpu.generic-x86.fltleaf@chip/cpu,			\
	    engine=serd.cpu.generic-x86.fltleaf@chip/cpu;		\
									\
	/* SERD engine for corrected events */				\
	engine serd.cpu.generic-x86.fltleaf@chip/cpu,			\
	    N=n, T=t, method=persistent,				\
	    trip=ereport.cpu.generic-x86.fltleaf/**/_error@chip/cpu;	\
									\
	/* Diagnose corrected events to the corresponding upset	*/	\
	prop upset.cpu.generic-x86.fltleaf@chip/cpu (1)->		\
	    ereport.cpu.generic-x86.erptleaf@chip/cpu;			\
									\
	/* When the engine trips, diagnose a fault */			\
	prop fault.cpu.generic-x86.fltleaf@chip/cpu (0)->		\
	    ereport.cpu.generic-x86.fltleaf/**/_error@chip/cpu;		\
									\
	/* Produce immediate faults for uncorrected errors */		\
	prop fault.cpu.generic-x86.fltleaf@chip/cpu (0)->		\
	    ereport.cpu.generic-x86.erptleaf/**/_uc@chip/cpu


CMPND_FLT_PROP_1(l0cache, l0cache, 3, 72h);
CMPND_FLT_PROP_1(l1cache, l1cache, 3, 72h);
CMPND_FLT_PROP_1(l2cache, l2cache, 3, 72h);
CMPND_FLT_PROP_1(cache, cache, 12, 72h);

CMPND_FLT_PROP_1(l0dtlb, l0dtlb, 3, 72h);
CMPND_FLT_PROP_1(l1dtlb, l1dtlb, 3, 72h);
CMPND_FLT_PROP_1(l2dtlb, l2dtlb, 3, 72h);
CMPND_FLT_PROP_1(dtlb, dtlb, 12, 72h);

CMPND_FLT_PROP_1(l0itlb, l0itlb, 3, 72h);
CMPND_FLT_PROP_1(l1itlb, l1itlb, 3, 72h);
CMPND_FLT_PROP_1(l2itlb, l2itlb, 3, 72h);
CMPND_FLT_PROP_1(itlb, itlb, 12, 72h);

CMPND_FLT_PROP_1(l0tlb, l0tlb, 3, 72h);
CMPND_FLT_PROP_1(l1tlb, l1tlb, 3, 72h);
CMPND_FLT_PROP_1(l2tlb, l2tlb, 3, 72h);
CMPND_FLT_PROP_1(tlb, tlb, 12, 72h);

CMPND_FLT_PROP_1(l0dcache, l0dcache, 3, 72h);
CMPND_FLT_PROP_1(l1dcache, l1dcache, 3, 72h);
CMPND_FLT_PROP_1(l2dcache, l2dcache, 3, 72h);
CMPND_FLT_PROP_1(dcache, dcache, 12, 72h);

CMPND_FLT_PROP_1(l0icache, l0icache, 3, 72h);
CMPND_FLT_PROP_1(l1icache, l1icache, 3, 72h);
CMPND_FLT_PROP_1(l2icache, l2icache, 3, 72h);
CMPND_FLT_PROP_1(icache, icache, 12, 72h);

/*
 * Compound error propogations for bus_interconnect* - as above but
 * with no FRU.
 */

#define	CMPND_FLT_PROP_2(erptleaf, fltleaf, n, t) \
	/* Declare the fault that we can diagnose here */		\
	event fault.cpu.generic-x86.fltleaf@chip/cpu,			\
	    FITrate=1000,						\
	    ASRU=motherboard/chip/cpu;					\
									\
	/* Produced when the correctable engine trips */		\
	event ereport.cpu.generic-x86.fltleaf/**/_error@chip/cpu	\
	    { within(1s) };						\
									\
	/* Upset to diagnose corrected events to */			\
	event upset.cpu.generic-x86.fltleaf@chip/cpu,			\
	    engine=serd.cpu.generic-x86.fltleaf@chip/cpu;		\
									\
	/* SERD engine for corrected events */				\
	engine serd.cpu.generic-x86.fltleaf@chip/cpu,			\
	    N=n, T=t, method=persistent,				\
	    trip=ereport.cpu.generic-x86.fltleaf/**/_error@chip/cpu;	\
									\
	/* Diagnose corrected events to the corresponding upset	*/	\
	prop upset.cpu.generic-x86.fltleaf@chip/cpu (1)->		\
	    ereport.cpu.generic-x86.erptleaf@chip/cpu;			\
									\
	/* When the engine trips, diagnose a fault */			\
	prop fault.cpu.generic-x86.fltleaf@chip/cpu (0)->		\
	    ereport.cpu.generic-x86.fltleaf/**/_error@chip/cpu;		\
									\
	/* Produce immediate faults for uncorrected errors */		\
	prop fault.cpu.generic-x86.fltleaf@chip/cpu (0)->		\
	    ereport.cpu.generic-x86.erptleaf/**/_uc@chip/cpu


CMPND_FLT_PROP_2(bus_interconnect, bus_interconnect, 10, 72h);
CMPND_FLT_PROP_2(bus_interconnect_memory, bus_interconnect_memory, 10, 72h);
CMPND_FLT_PROP_2(bus_interconnect_io, bus_interconnect_io, 10, 72h);

/*
 * Discards - not enough info to diagnose.
 */
event upset.discard@chip/cpu;

prop upset.discard@chip/cpu (0)->
    ereport.cpu.generic-x86.external@chip/cpu,
    ereport.cpu.generic-x86.unknown@chip/cpu;

