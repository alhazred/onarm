/*
 * CDDL HEADER START
 *
 * The contents of this file are subject to the terms of the
 * Common Development and Distribution License (the "License").
 * You may not use this file except in compliance with the License.
 *
 * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
 * or http://www.opensolaris.org/os/licensing.
 * See the License for the specific language governing permissions
 * and limitations under the License.
 *
 * When distributing Covered Code, include this CDDL HEADER in each
 * file and include the License file at usr/src/OPENSOLARIS.LICENSE.
 * If applicable, add the following below this CDDL HEADER, with the
 * fields enclosed by brackets "[]" replaced with your own identifying
 * information: Portions Copyright [yyyy] [name of copyright owner]
 *
 * CDDL HEADER END
 */
/*
 * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.
 * Use is subject to license terms.
 */

#pragma ident	"%Z%%M%	%I%	%E% SMI"

#pragma dictionary "PCIEX"

#include <fm/topo_hc.h>

/*
 * FIT rates - assume leaf devices are somewhat less reliable than
 * root complexes, switches and bridges
 */
#define PCIEX_RC_FIT 500
#define PCIEX_SW_FIT 500
#define PCIEX_BDG_FIT 500
#define PCIEX_DEV_FIT 1000
#define PCIEX_RC_INV_FIT 500
#define PCIEX_DEV_INV_FIT 1000
#define PCIEX_RC_NR_FIT 500
#define PCIEX_SW_NR_FIT 500
#define PCIEX_BDG_NR_FIT 500
#define PCIEX_DEV_NR_FIT 1000
#define PCIEX_BUS_FIT 500
#define PCIEX_BUS_NR_FIT 500

/*
 * SERD parameters.
 * 
 * PCI Express correctable link errors are automatically handled by the
 * hardware, so have relatively little impact and we can allow quite a
 * high frequency. We will also be quite conservative about nonfatal internal
 * errors reported by the driver.
 *
 * Nonfatal dpe errors (ptlp/ecrc errors) have to be recovered by the hardened
 * driver which may cause intermittant performance/responsiveness problems, so
 * we have tighter serd parameters for these. These are most likely errors in
 * buffers/caches within devices and bridges, so use similar rates to cpu
 * data cache parity errors.
 */
#define CORRLINK_COUNT 6
#define CORRLINK_TIME 2h
#define NONFATAL_COUNT 6
#define NONFATAL_TIME 2h
#define NONFATAL_DPE_U_COUNT 3
#define NONFATAL_DPE_U_TIME 168h
#define NONFATAL_DPE_D_COUNT 3
#define NONFATAL_DPE_D_TIME 168h

/*
 * if the source-id payload is valid, then check it matches
 */
#define SOURCE_ID_MATCHES_BDF \
	(!payloadprop_defined("source-valid") || \
	payloadprop("source-valid") == 0 || \
	payloadprop("source-id") == ((b << 8) | (d << 3) | f))

#define SOURCE_ID_MATCHES_OWN_BDF \
	(payloadprop_defined("source-valid") && \
	payloadprop("source-valid") == 1 && \
	payloadprop("source-id") == (confprop(asru(pciexrc), TOPO_PCI_BDF) + 0))

/*
 * Other useful macros. These use the EXCAP property (PCI Express Capabilities
 * register) to find the type for PCI Express devices, and the CLASS-CODE
 * property (PCI Class Code register) for to find the type of PCI devices behind
 * a PCI Express-PCI bridge - note that 60400 and 60401 are defined as PCI-PCI
 * bridges, everything else is consider a PCI leaf device.
 */
#define BDF_IS_UNDER_RC \
	is_under(pciexrc<>, pciexbus[b]/pciexdev[d]/pciexfn[f])

#define PCIBDF_IS_UNDER_RC \
	is_under(pciexrc<>, pcibus[b]/pcidev[d]/pcifn[f])

#define PCIBDF_IS_UNDER_DEV \
	is_under(pciexbus/pciexdev/pciexfn, pcibus[b]/pcidev[d]/pcifn[f])

#define IS_SWD \
	(confprop(asru(pciexbus/pciexdev/pciexfn), TOPO_PCI_EXCAP) == \
	"pciexswd")

#define IS_SWU \
	(confprop(asru(pciexbus/pciexdev/pciexfn), TOPO_PCI_EXCAP) == \
	"pciexswu")

#define IS_LEAF \
	(confprop(asru(pciexbus/pciexdev/pciexfn), TOPO_PCI_EXCAP) == \
	"pciexdev")

#define	IS_PCI_LEAF \
	(confprop_defined(asru(pcibus/pcidev/pcifn), TOPO_PCI_CLASS) && \
	confprop(asru(pcibus/pcidev/pcifn), TOPO_PCI_CLASS) != "60400" && \
	confprop(asru(pcibus/pcidev/pcifn), TOPO_PCI_CLASS) != "60401")

#define	BDF_IS_PCI_LEAF \
	(confprop_defined(asru(pcibus[b]/pcidev[d]/pcifn[f]), \
	TOPO_PCI_CLASS) && \
	confprop(asru(pcibus[b]/pcidev[d]/pcifn[f]), TOPO_PCI_CLASS) != \
	"60400" && \
	confprop(asru(pcibus[b]/pcidev[d]/pcifn[f]), TOPO_PCI_CLASS) != "60401")

#define IS_BDG \
	(confprop(asru(pciexbus/pciexdev/pciexfn), TOPO_PCI_EXCAP) == \
	"pcibus")

#define BDF_IS_LEAF \
	(confprop(asru(pciexbus[b]/pciexdev[d]/pciexfn[f]), \
	TOPO_PCI_EXCAP) == "pciexdev")

/*
 * define faults
 */
asru pciexrc;
fru pciexrc;
asru pciexbus/pciexdev/pciexfn;
fru pciexbus/pciexdev;
fru pciexbus;
asru pciexbus;

event fault.io.pciex.device-interr@pciexbus/pciexdev/pciexfn,
	FITrate=PCIEX_DEV_FIT, FRU=pciexbus/pciexdev,
	ASRU=pciexbus/pciexdev/pciexfn;

event fault.io.pciex.device-interr@pciexrc,
	FITrate=PCIEX_RC_FIT, FRU=pciexrc, ASRU=pciexrc;

event fault.io.pciex.device-invreq@pciexbus/pciexdev/pciexfn,
	FITrate=PCIEX_DEV_INV_FIT, FRU=pciexbus/pciexdev,
	ASRU=pciexbus/pciexdev/pciexfn;

event upset.io.pciex.device-invreq@pciexrc;

event fault.io.pciex.device-noresp@pciexbus/pciexdev/pciexfn,
	FITrate=PCIEX_DEV_NR_FIT, FRU=pciexbus/pciexdev,
	ASRU=pciexbus/pciexdev/pciexfn;

event fault.io.pciex.device-noresp@pciexrc,
	FITrate=PCIEX_RC_NR_FIT, FRU=pciexrc, ASRU=pciexrc;

event fault.io.pciex.bus-noresp@pciexbus/pciexdev/pciexfn,
        FITrate=PCIEX_BUS_NR_FIT, FRU=pciexbus, ASRU=pciexbus/pciexdev/pciexfn;

event fault.io.pciex.bus-linkerr@pciexbus/pciexdev/pciexfn,
        FITrate=PCIEX_BUS_FIT, FRU=pciexbus, ASRU=pciexbus/pciexdev/pciexfn;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * serd engine for correctable link errors
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event error.io.pciex.corrlink@pciexbus;
event error.io.pciex.corrlink@pciexrc/pciexbus;
event error.io.pciex.corrlink@pciexbus/pciexdev/pciexfn/pciexbus;
event error.io.pciex.corrlink_trip@pciexbus;
event ereport.io.pciex.corrlink_trip@pciexbus{within(5s)};

engine serd.io.pciex.corrlink@pciexbus,
    N=CORRLINK_COUNT, T=CORRLINK_TIME, method=persistent,
    trip=ereport.io.pciex.corrlink_trip@pciexbus;

event upset.io.pciex.corrlink@pciexbus,
    engine=serd.io.pciex.corrlink@pciexbus;

prop upset.io.pciex.corrlink@pciexbus (1)->
    error.io.pciex.corrlink@pciexbus;

prop error.io.pciex.corrlink_trip@pciexbus (1)->
    ereport.io.pciex.corrlink_trip@pciexbus;

prop error.io.pciex.corrlink_trip@pciexbus (0)->
   error.io.pciex.corrlink@pciexbus;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Handling of leaf driver detected internal errors. Use serd engine if
 * no service impact - otherwise fail immediately
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event ereport.io.device.inval_state@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.device.no_response@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.device.stall@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.device.badint_limit@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.device.intern_corr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.device.intern_uncorr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.service.lost@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.service.degraded@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.service.restored@pciexbus/pciexdev/pciexfn{within(30s)};
event ereport.io.device.nf-device@pciexbus/pciexdev/pciexfn{within(5s)};

event error.io.service.restored@pciexbus/pciexdev/pciexfn;
event error.io.device.nf-device@pciexbus/pciexdev/pciexfn;
event error.io.device.f-device@pciexbus/pciexdev/pciexfn;

prop error.io.device.f-device@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.device.inval_state@pciexbus/pciexdev/pciexfn,
    ereport.io.device.no_response@pciexbus/pciexdev/pciexfn,
    ereport.io.device.stall@pciexbus/pciexdev/pciexfn,
    ereport.io.device.badint_limit@pciexbus/pciexdev/pciexfn,
    ereport.io.device.intern_corr@pciexbus/pciexdev/pciexfn,
    ereport.io.device.intern_uncorr@pciexbus/pciexdev/pciexfn;

prop error.io.device.f-device@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn,
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn;

engine serd.io.device.nonfatal@pciexbus/pciexdev/pciexfn,
    N=NONFATAL_COUNT, T=NONFATAL_TIME, method=persistent,
    trip=ereport.io.device.nf-device@pciexbus/pciexdev/pciexfn;

event upset.io.device.nonfatal@pciexbus/pciexdev/pciexfn,
    engine=serd.io.device.nonfatal@pciexbus/pciexdev/pciexfn;

prop error.io.device.nf-device@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.device.nf-device@pciexbus/pciexdev/pciexfn;

prop error.io.device.nf-device@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.device.inval_state@pciexbus/pciexdev/pciexfn,
    ereport.io.device.no_response@pciexbus/pciexdev/pciexfn,
    ereport.io.device.stall@pciexbus/pciexdev/pciexfn,
    ereport.io.device.badint_limit@pciexbus/pciexdev/pciexfn,
    ereport.io.device.intern_corr@pciexbus/pciexdev/pciexfn,
    ereport.io.device.intern_uncorr@pciexbus/pciexdev/pciexfn,
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn,
    error.io.service.restored@pciexbus/pciexdev/pciexfn;

prop upset.io.device.nonfatal@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.device.inval_state@pciexbus/pciexdev/pciexfn,
    ereport.io.device.no_response@pciexbus/pciexdev/pciexfn,
    ereport.io.device.stall@pciexbus/pciexdev/pciexfn,
    ereport.io.device.badint_limit@pciexbus/pciexdev/pciexfn,
    ereport.io.device.intern_corr@pciexbus/pciexdev/pciexfn,
    ereport.io.device.intern_uncorr@pciexbus/pciexdev/pciexfn;

prop upset.io.device.nonfatal@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn,
    error.io.service.restored@pciexbus/pciexdev/pciexfn;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Handling of pci express nonfatal errors (ptlp/ecrc). Use serd engine if
 * no service impact - otherwise fail immediately
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event ereport.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn{within(5s)};

event error.io.pciex.flt-f-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-ecrcreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-ecrccomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-poisreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-poiscomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-ecrcreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-ecrccomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-poiscomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-poisreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-poiscomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-ecrcreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-ecrccomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-poiscomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-f-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-f-ecrcreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-ecrccomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-poisreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-poiscomp-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-f-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-f-ecrcreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-ecrccomp-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-poisreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-poiscomp-d@pciexbus/pciexdev/pciexfn;

engine serd.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn,
    N=NONFATAL_DPE_U_COUNT, T=NONFATAL_DPE_U_TIME, method=persistent,
    trip=ereport.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn;

event upset.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn,
    engine=serd.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.flt-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poisreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poiscomp-u@pciexbus/pciexdev/pciexfn;

prop upset.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poisreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poiscomp-u@pciexbus/pciexdev/pciexfn;

engine serd.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn,
    N=NONFATAL_DPE_D_COUNT, T=NONFATAL_DPE_D_TIME, method=persistent,
    trip=ereport.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn;

event upset.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn,
    engine=serd.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.flt-nf-ecrcreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-ecrccomp-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poisreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poiscomp-d@pciexbus/pciexdev/pciexfn;

prop upset.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-nf-ecrcreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-ecrccomp-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poisreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-nf-poiscomp-d@pciexbus/pciexdev/pciexfn;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCI Express hostbridge (root complex) may cause:
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - nr-d:		the device not to respond to a valid upstream request
 * - ca-d:		the device to completer abort a valid upstream request
 * - mtlp-d:		a malformed tlp to be transmitted downstream
 * - badreq-d:		a bad downstream request - not CRC error (may cause
 *			completer to respond with ur or ca)
 * - ecrcreq-d:		TLP with end-to-end CRC error transmitted downstream
 * - ecrccomp-d:	TLP with end-to-end CRC error transmitted downstream
 * - poisreq-d:		poisoned request transmitted downstream
 * - poiscomp-d:	poisoned completion transmitted downstream
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */
event error.io.pciex.nr-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-ca-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.mtlp-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.badreq-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.corrlink_trip@pciexrc/pciexbus;
event error.io.pciex.fatlink@pciexrc/pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.device-noresp@pciexrc (1)->
    error.io.pciex.nr-d@pciexrc/pciexbus<>/pciexdev<>/pciexfn<>;

prop upset.io.pciex.device-invreq@pciexrc (1)->
    error.io.pciex.badreq-d@pciexrc/pciexbus<>/pciexdev<>/pciexfn<>;

prop fault.io.pciex.device-interr@pciexrc (1)->
    error.io.pciex.flt-nf-d@pciexrc/pciexbus<>/pciexdev<>/pciexfn<>,
    error.io.pciex.flt-f-d@pciexrc/pciexbus<>/pciexdev<>/pciexfn<>,
    error.io.pciex.flt-ca-d@pciexrc/pciexbus<>/pciexdev<>/pciexfn<>,
    error.io.pciex.mtlp-d@pciexrc/pciexbus<>/pciexdev<>/pciexfn<>,
    error.io.pciex.corrlink_trip@pciexrc/pciexbus<>,
    error.io.pciex.fatlink@pciexrc/pciexbus<>/pciexdev<>/pciexfn<>;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCI Express leaf device or upstream switch port may cause:
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - nr-u:		the device not to respond to a valid downstream request
 * - ca-u:		the device to completer abort a valid downstream request
 * - badreq-u:		a bad upstream request - not CRC error (may cause
 *			completer to respond with ur or ca) - leaf only
 * - mtlp-u:		a malformed tlp transmitted upstream - leaf only
 * - ecrcreq-u:		request with end-to-end CRC error transmitted upstream
 * - ecrccomp-u:	compl with end-to-end CRC error transmitted upstream
 * - poisreq-u:		poisoned request transmitted upstream
 * - poiscomp-u:	poisoned completion transmitted upstream
 * - device:		internal error reported by leaf device
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */

event error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.mtlp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-badreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.device-noresp@pciexbus/pciexdev/pciexfn { IS_LEAF } (1)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.device-noresp@pciexbus/pciexdev/pciexfn { IS_SWU } (1)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.device-invreq@pciexbus/pciexdev/pciexfn { IS_LEAF } (1)->
    error.io.pciex.flt-badreq-u@pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.device-interr@pciexbus/pciexdev/pciexfn { IS_SWU } (1)->
    error.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.corrlink_trip@pciexbus,
    error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.device-interr@pciexbus/pciexdev/pciexfn { IS_LEAF } (1)->
    error.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-u@pciexbus/pciexdev/pciexfn,
    error.io.device.nf-device@pciexbus/pciexdev/pciexfn,
    error.io.device.f-device@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.mtlp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.corrlink_trip@pciexbus,
    error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCI Express downstream switch port may cause
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - nr-d:		the device not to respond to an upstream request
 * - ca-d:		the device to completer abort an upstream request
 * - ecrcreq-d:		TLP with end-to-end CRC error transmitted upstream
 * - ecrccomp-d:	TLP with end-to-end CRC error transmitted upstream
 * - poisreq-d:		poisoned request transmitted upstream
 * - poiscomp-d:	poisoned completion transmitted upstream
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */

event error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-ca-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-f-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.corrlink_trip@pciexbus/pciexdev/pciexfn/pciexbus;
event error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.device-noresp@pciexbus/pciexdev/pciexfn { IS_SWD } (1)->
    error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;

prop fault.io.pciex.device-interr@pciexbus/pciexdev/pciexfn { IS_SWD } (1)->
    error.io.pciex.flt-ca-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>,
    error.io.pciex.flt-nf-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>,
    error.io.pciex.flt-f-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>,
    error.io.pciex.corrlink_trip@pciexbus/pciexdev/pciexfn/pciexbus<>,
    error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty PCIEX bus may cause:
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * - nr-u:		a device to not respond because the link is down
 * - nr-d:		a device to not respond because the link is down
 * - corrlink:		correctable link or physical level error
 * - fatlink:		fatal link or physical level error
 */

event error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn;

prop fault.io.pciex.bus-noresp@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG },
    error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG };

prop fault.io.pciex.bus-linkerr@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.corrlink_trip@pciexbus,
    error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG };

/*
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * A faulty pciex-pci bridge may cause
 * ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * The following errors to propagate onto the PCI Express fabric
 * - nr-u:		the device not to respond to a valid downstream request
 * - ca-u:		the device to completer abort a valid downstream request
 * - ecrcreq-u:		request with end-to-end CRC error transmitted upstream
 * - ecrccomp-u:	compl with end-to-end CRC error transmitted upstream
 * - poisreq-u:		poisoned request transmitted upstream
 * - poiscomp-u:	poisoned completion transmitted upstream
 * - corrlink:		correctable link or physical level error upstream
 * - fatlink:		fatal link or physical level error upstream
 * - sec-interr:	internal error on pci express to pci bridge
 *
 * And the following errors to propagate onto the secondary pci or pci/x bus
 * (these will be handled by code in the pci.esc file).
 * - nr-pw-d:		the device not to respond to a valid upstream request
 * - nr-drw-d:		the device not to respond to a valid upstream request
 * - retry-to-d:	failure to retry an downstream delayed request
 * - ta-pw-d:		the device responds with a ta to a valid upstream
 *			request
 * - ta-drw-d:		the device responds with a ta to a valid upstream
 *			request
 * - ape-d:	address/parity to get corrupted during downstream transmission.
 * - dpe-d:	data/parity to get corrupted during downstream transmission.
 * - scpe-d:	split completion to get corrupted during downstream transmission
 */

event error.io.pci.ape-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.f-dpe-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.nf-dpe-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.retry-to-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.nr-pw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.nr-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.ta-pw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.ta-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pcix.scpe-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.sec-interr@pciexbus/pciexdev/pciexfn;
event ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn{within(5s)};

prop fault.io.pciex.device-noresp@pciexbus/pciexdev/pciexfn { IS_BDG } (1)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn,
    error.io.pci.retry-to-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.nr-pw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.nr-drw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop fault.io.pciex.device-interr@pciexbus/pciexdev/pciexfn { IS_BDG } (1)->
    error.io.pciex.flt-nf-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-f-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.mtlp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.sec-interr@pciexbus/pciexdev/pciexfn,
    error.io.pciex.corrlink_trip@pciexbus,
    error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn,
    error.io.pci.ta-pw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.ta-drw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.ape-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pcix.scpe-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.f-dpe-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.nf-dpe-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop fault.io.pciex.device-interr@pciexbus/pciexdev/pciexfn { IS_BDG } (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * declarations
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event error.io.pciex.fatal@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ur-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ur-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.ur-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.nr-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nr-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.nr-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.ca-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.mtlp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.sw-mtlp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.mtlp-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.flt-ca-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ca-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.poisreq-d@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.sw-poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ecrcreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.sw-ecrcreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ecrccomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.badreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.badreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.badreq-u@pciexbus/pciexdev;
event error.io.pciex.badreq-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.ecrcreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ecrcreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-ecrcreq-u@pcibus/pcidev/pcifn;
event error.io.pciex.source-nf-ecrcreq-u@pcibus/pcidev/pcifn;
event error.io.pciex.ecrccomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.ecrccomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-ecrccomp-u@pcibus/pcidev/pcifn;
event error.io.pciex.source-nf-ecrccomp-u@pcibus/pcidev/pcifn;
event error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.poiscomp-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-poiscomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-poiscomp-u@pciexbus/pciexdev/pciexfn;
event error.io.pci.source-f-dpdata-r-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-nf-dpdata-r-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-f-dpdata-r-u@pcibus/pcidev/pcifn;
event error.io.pci.source-nf-dpdata-r-u@pcibus/pcidev/pcifn;
event error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.poisreq-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pci.source-f-dpdata-w-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-nf-dpdata-w-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-f-dpdata-w-u@pcibus/pcidev/pcifn;
event error.io.pci.source-nf-dpdata-w-u@pcibus/pcidev/pcifn;
event error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-mtlp-u@pcibus/pcidev/pcifn;
event error.io.pci.badreq-pw-u@pcibus/pcidev/pcifn;
event error.io.pci.badreq-drw-u@pcibus/pcidev/pcifn;
event error.io.pci.badreq-pw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.badreq-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn;
event error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn;
event error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-lf-poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.anf-poisreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.anf-poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-lf-poiscomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.anf-poiscomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.anf-poiscomp-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.f-ecrcreq-d@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.f-ecrcreq-d@pcibus/pcidev/pcifn;
event error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.nf-ecrcreq-d@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.nf-ecrcreq-d@pcibus/pcidev/pcifn;
event error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.f-ecrccomp-d@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.f-ecrccomp-d@pcibus/pcidev/pcifn;
event error.io.pciex.f-lf-ecrccomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.nf-ecrccomp-d@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.nf-ecrccomp-d@pcibus/pcidev/pcifn;
event error.io.pciex.f-lf-poisreq-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.fatal-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.nonfatal-u@pciexbus/pciexdev/pciexfn;
event error.io.pciex.fatal-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.nonfatal-u@pciexrc/pciexbus/pciexdev/pciexfn;
event error.io.pciex.fatal-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.nonfatal-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.service.restored@pcibus/pcidev/pcifn;

event ereport.io.pci.ma@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.rta@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.sta@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.service.lost@pcibus/pcidev/pcifn{within(5s)};
event ereport.io.service.degraded@pcibus/pcidev/pcifn{within(5s)};
event ereport.io.service.unaffected@pcibus/pcidev/pcifn{within(5s)};
event ereport.io.pciex.dl.dllp@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.dl.btlp@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.dl.bdllp@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.dl.rto@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.dl.rnr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.pl.re@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.pl.te@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.fcp@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.rof@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.mtlp@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.ur@pciexfn{within(5s)};
event ereport.io.pciex.tl.ca@pciexfn{within(5s)};
event ereport.io.pciex.tl.ur@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.uc@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.tl.cto@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.dl.dllp@pciexrc{within(5s)};
event ereport.io.pciex.dl.btlp@pciexrc{within(5s)};
event ereport.io.pciex.dl.bdllp@pciexrc{within(5s)};
event ereport.io.pciex.dl.rto@pciexrc{within(5s)};
event ereport.io.pciex.dl.rnr@pciexrc{within(5s)};
event ereport.io.pciex.pl.re@pciexrc{within(5s)};
event ereport.io.pciex.pl.te@pciexrc{within(5s)};
event ereport.io.pciex.tl.fcp@pciexrc{within(5s)};
event ereport.io.pciex.tl.rof@pciexrc{within(5s)};
event ereport.io.pciex.tl.mtlp@pciexrc{within(5s)};
event ereport.io.pciex.tl.ur@pciexrc{within(5s)};
event ereport.io.pciex.tl.ca@pciexrc{within(5s)};
event ereport.io.pciex.tl.ptlp@pciexrc{within(5s)};
event ereport.io.pciex.tl.ecrc@pciexrc{within(5s)};
event ereport.io.pciex.tl.cto@pciexrc{within(5s)};
event ereport.io.pci.sec-ma@pciexrc{within(5s)};
event ereport.io.pci.sec-mdpe@pciexrc{within(5s)};
event ereport.io.pci.sec-dpe@pciexrc{within(5s)};
event ereport.io.pci.sec-rta@pciexrc{within(5s)};
event ereport.io.pci.sec-sta@pciexrc{within(5s)};
event ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.sec-rserr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.sserr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.sec-rserr@pciexrc{within(5s)};
event ereport.io.pciex.rc.fe-msg@pciexrc{within(5s)};
event ereport.io.pciex.rc.nfe-msg@pciexrc{within(5s)};
event ereport.io.pciex.bdg.sec-interr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-ude@pciexbus/pciexdev/pciexfn{within(5s)};

/*
 * handling of fatal and nonfatal error messages propagated up to root complex
 *
 * Use these for errors reported by root-complex on behalf of another device.
 * Can use source-id payload to identify where the message came from.
 */
prop error.io.pciex.fatal@pciexbus[b]/pciexdev[d]/pciexfn[f] (1)->
    ereport.io.pciex.rc.fe-msg@pciexrc<> {
	SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.fatal@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.fatal-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.fatal-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sserr@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.fatal-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.fatal-u@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-rserr@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.fatal-u@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-rserr@pciexrc;

prop error.io.pciex.nonfatal@pciexbus[b]/pciexdev[d]/pciexfn[f] (1)->
    ereport.io.pciex.rc.nfe-msg@pciexrc<> {
	SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nonfatal-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sserr@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nonfatal-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.nonfatal-u@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-rserr@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nonfatal-u@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-rserr@pciexrc;

/*
 * link-level errors - could generate ereports at either end of link
 * 
 * can use may propagations here as these ereports are only seen for these
 * faults.
 */
prop error.io.pciex.corrlink@pciexbus (0)->
    ereport.io.pciex.dl.btlp@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG },
    ereport.io.pciex.dl.bdllp@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG },
    ereport.io.pciex.dl.rto@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG },
    ereport.io.pciex.dl.rnr@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG },
    ereport.io.pciex.pl.re@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG };

prop error.io.pciex.corrlink@pciexbus/pciexdev/pciexfn/pciexbus (0)->
    ereport.io.pciex.dl.btlp@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.dl.bdllp@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.dl.rto@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.dl.rnr@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.pl.re@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.corrlink@pciexrc/pciexbus (0)->
    ereport.io.pciex.dl.btlp@pciexrc,
    ereport.io.pciex.dl.bdllp@pciexrc,
    ereport.io.pciex.dl.rto@pciexrc,
    ereport.io.pciex.dl.rnr@pciexrc,
    ereport.io.pciex.pl.re@pciexrc;

prop error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG };

prop error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.dl.dllp@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG },
    ereport.io.pciex.tl.fcp@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG },
    ereport.io.pciex.tl.rof@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG };

prop error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn
(0)->
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.fatlink@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.dl.dllp@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.pl.te@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.tl.fcp@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.tl.rof@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.fatlink@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.dl.dllp@pciexrc,
    ereport.io.pciex.pl.te@pciexrc,
    ereport.io.pciex.tl.fcp@pciexrc,
    ereport.io.pciex.tl.rof@pciexrc;

/*
 * bridge internal error
 */
prop error.io.pciex.sec-interr@pciexbus/pciexdev/pciexfn (2) ->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_BDG },
    ereport.io.pciex.bdg.sec-interr@pciexbus/pciexdev/pciexfn { IS_BDG };

/*
 * downstream poisoned request
 *
 * - poisreq-d cascades down to the leaf device/bridge and any switch ports
 *   on route must raise a ptlp ereport while any switch ports forwarding
 *   the poisoned request must raise sec-mdpe ereports. The originator of the
 *   poisoning (be it root complex or downstream port of a switch) also raises
 *   sec-mdpe. A hardened leaf driver will also raise ptlp. A target-mdpe
 *   cascades down to the leaf (which may be a pci device beyond the bridge).
 *
 * Additionally, the leaf/bridge may treat the request as a ur, which the
 * root complex will see and report an ma. Use flt-ur-u to represent this.
 * Note that sw-poisreq-d is to handle the case where the switch is actually
 * the target of the packet (config request etc).
 *
 * The fault can always be recognized and the source identified using the ptlp
 * and sec-mdpe ereports.
 */
prop error.io.pciex.flt-f-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.sw-poisreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.f-lf-poisreq-d@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.f-lf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-lf-poisreq-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn,
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn,
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.flt-nf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.anf-poisreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.service.restored@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn,
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn;

prop error.io.service.restored@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.restored@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.anf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.anf-poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.anf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.anf-poisreq-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.poisreq-d@pciexrc/pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.sec-mdpe@pciexrc;

prop error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn { IS_SWU };

prop error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_SWU || IS_BDG },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWU || IS_BDG };

prop error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.sw-poisreq-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn { IS_SWU };

prop error.io.pciex.sw-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn { IS_SWU };

/*
 * downstream poisoned completion
 *
 * - poiscomp-d cascades down to the leaf device/bridge and any switch ports on
 *   route must raise ptlp and mdpe ereports.  A hardened leaf driver will also
 *   raise pltp and mdpe. For non-hardened leaf devices, no ptlp/mdpe may be
 *   reported, and though we should still see a nonfatal error reported from
 *   the root complex identifying the leaf device, we won't actually be informed
 *   that the error was an ptlp.
 */
prop error.io.pciex.flt-f-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.f-lf-poiscomp-d@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.f-lf-poiscomp-d@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-lf-poiscomp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn,
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn,
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.flt-nf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.anf-poiscomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.anf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.anf-poiscomp-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.anf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.anf-poiscomp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn (3)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_BDG },
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_BDG },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_SWU },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWU };

prop error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_SWU },
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn { IS_SWU };

prop error.io.pciex.poiscomp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pci.dpe@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWD };

/*
 * downstream request with ecrc error.
 *
 * - ecrcreq-d cascades down to the leaf device/bridge and any switches on
 *   route can optionally raise an ecrc ereport. A hardened leaf driver may also
 *   raise ecrc. For non-hardened leaf devices, no ecrc may be reported, and
 *   though we should still see a nonfatal error reported from the root complex
 *   identifying the leaf device, we won't actually be informed that the error
 *   was an ecrc.
 *
 * Additionally, as the leaf/bridge will just throw away the packet, we should
 * eventually get a cto at the root complex - so use an flt-nr-u at the pciex
 * leaf or bridge to get the appropriate behaviour. For the case where the leaf
 * driver wasn't hardened we may be able to identify the leaf device (and
 * therefore any intermediate switches which might have caused the problem)
 * either via a target-ma ereport if available or via the nonfatal error
 * reported from the root complex identifying the leaf device. The combination
 * of a nonfatal error reported from the root complex and a cto from the root
 * complex is sufficient to positively identify this case.
 *
 * Note that sw-ecrcreq-d is to handle the case where the switch is actually
 * the target of the packet (config request etc).
 */
prop error.io.pciex.flt-f-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.sw-ecrcreq-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.f-ecrcreq-d@pcibus/pcidev/pcifn (1)->
    error.io.pciex.f-ecrcreq-d@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.f-ecrcreq-d@pcibus/pcidev/pcifn (0)->
    ereport.io.service.lost@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    ereport.io.service.degraded@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ecrcreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-ecrcreq-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.flt-nf-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.nf-ecrcreq-d@pcibus/pcidev/pcifn (1)->
    error.io.pciex.nf-ecrcreq-d@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.nf-ecrcreq-d@pcibus/pcidev/pcifn (1)->
    ereport.io.service.unaffected@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    error.io.service.restored@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ecrcreq-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.ecrcreq-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.ecrcreq-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.ecrcreq-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_SWU || IS_SWD };

prop error.io.pciex.sw-ecrcreq-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn { IS_SWU };

/*
 * downstream completion with ecrc error.
 *
 * - ecrccomp-d cascades down to the leaf device/bridge and any switches on
 *   route can optionally raise an ecrc ereport. A hardened leaf driver may
 *   also raise ecrc. For non-hardened leaf devices, no ecrc may be reported,
 *   and though we should still see a nonfatal error reported from the root
 *   complex identifying the leaf device, we won't actually be informed that
 *   the error was an ecrc.
 *
 * Additionally, as the leaf/bridge will just throw away the packet, we should
 * eventually get a cto. Note the leaf ereports are optional (ie in case driver
 * not hardened) but if we get both ecrc and cto we need to distinguish from
 * cto only which would be an nr-d.
 */
prop error.io.pciex.flt-f-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.f-ecrccomp-d@pcibus/pcidev/pcifn (1)->
    error.io.pciex.f-ecrccomp-d@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.f-ecrccomp-d@pcibus/pcidev/pcifn (0)->
    ereport.io.service.lost@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    ereport.io.service.degraded@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ecrccomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-ecrccomp-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.f-lf-ecrccomp-d@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.f-lf-ecrccomp-d@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.tl.cto@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-lf-ecrccomp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-nf-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.nf-ecrccomp-d@pcibus/pcidev/pcifn (1)->
    error.io.pciex.nf-ecrccomp-d@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>; 

prop error.io.pciex.nf-ecrccomp-d@pcibus/pcidev/pcifn (1)->
    ereport.io.service.unaffected@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    error.io.service.restored@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ecrccomp-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.pciex.tl.cto@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nf-ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.ecrccomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.ecrccomp-d@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_BDG },
    error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.ecrccomp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_SWU || IS_SWD };

/*
 * upstream poisoned request
 *
 * - flt-poisreq-u is just on the pciex node which generated the fault (if the
 *   fault was generated by a pciex node and not a child pci node).
 * - source-poisreq-u cascades down to at least one leaf device (pciex or pci),
 *   whose bdf (if pciex) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - poisreq-u cascades up to the root complex and any switch ports on
 *   route will raise a ptlp ereport, while any upstream devices generating
 *   or forwarding the poisoned packed will raise an mdpe ereport. The root
 *   complex should also report a ptlp.
 *
 * Additionally, as the root complex may treat the request as a ur, which the
 * leaf/bridge will see (and if hardened report) as an ma (including sending a 
 * ta onto the child pci bus if this was a delayed write).
 *
 * We can always recognize what sort of fault this is from the ptlp (with no
 * sec-mdpe) at the root complex. Recognizing which originating devices may be
 * implicated can be done using the mdpe ereport (for a hardened leaf driver),
 * or for a non-hardened leaf driver by using the source-id payload in the ptlp
 * ereport to identify the originator of the request.  The ptlp/mdpe ereports
 * at the intervening switches will narrow the fault down to a single suspect.
 */

prop error.io.pciex.flt-f-poisreq-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.f-lf-poisreq-u@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.f-lf-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn,
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.f-lf-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-f-poisreq-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> {
	BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC },
    ereport.io.pciex.tl.ur@pciexrc<> {
	BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn,
    error.io.pci.ta-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;

prop error.io.pci.source-f-dpdata-w-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> { PCIBDF_IS_UNDER_RC },
    ereport.io.pciex.tl.ur@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pci.source-f-dpdata-w-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-ude@pciexbus/pciexdev/pciexfn { IS_BDG &&
        BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pciex.flt-nf-poisreq-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-nf-poisreq-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> {
	BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC },
    ereport.io.pciex.tl.ur@pciexrc<> {
	BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn,
    error.io.pci.ta-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;

prop error.io.pci.source-nf-dpdata-w-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> { PCIBDF_IS_UNDER_RC },
    ereport.io.pciex.tl.ur@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pci.source-nf-dpdata-w-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-ude@pciexbus/pciexdev/pciexfn { IS_BDG &&
        BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn,
    error.io.pci.ta-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn { IS_SWU },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWU };

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_BDG || IS_SWU };

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.poisreq-u@pciexrc/pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.sec-dpe@pciexrc;

/*
 * upstream poisoned completion
 *
 * - flt-poiscomp-u is just on the pciex node which generated the fault (if the
 *   fault was generated by a pciex node and not a child pci node). There will
 *   be a target-mdpe downstream from here.
 * - source-poiscomp-u cascades down to at least one leaf device (pciex or pci),
 *   whose bdf (if pciex) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - poiscomp-u cascades up to the root complex and any switches on
 *   route will raise ptlp and sec-mdpe ereports. The root complex will also
 *   raise a sec-mdpe and ptlp.
 *
 * We can always recognize what sort of fault this is from the ptlp/sec-mdpe at
 * the root complex. Recognizing which originating devices may be implicated
 * can be done using the source-id payload in the ptlp ereport to identify the
 * originator of the completion. The ptlp/sec-mdpe ereports at the intervening
 * switches will narrow the fault down to a single suspect.
 */
prop error.io.pciex.flt-f-poiscomp-u@pciexbus/pciexdev/pciexfn (3)->
    error.io.pciex.source-f-poiscomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-f-poiscomp-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-f-poiscomp-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> {
	SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pci.source-f-dpdata-r-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pci.source-f-dpdata-r-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-ude@pciexbus/pciexdev/pciexfn { IS_BDG &&
        BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pciex.flt-nf-poiscomp-u@pciexbus/pciexdev/pciexfn (3)->
    error.io.pciex.source-nf-poiscomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-nf-poiscomp-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-nf-poiscomp-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> {
	SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pci.source-nf-dpdata-r-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ptlp@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pci.source-nf-dpdata-r-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-ude@pciexbus/pciexdev/pciexfn { IS_BDG &&
        BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn { IS_SWD },
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn { IS_SWU },
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn { IS_SWU },
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn { IS_SWU },
    ereport.io.pciex.tl.ptlp@pciexbus/pciexdev/pciexfn { IS_SWU };

prop error.io.pciex.poiscomp-u@pciexrc/pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.sec-dpe@pciexrc;

prop error.io.pciex.poiscomp-u@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-mdpe@pciexrc;

/*
 * upstream request with ecrc error.
 *
 * - flt-ecrcreq-u is just on the pciex node which generated the fault.
 * - source-ecrcreq-u cascades down to at least one leaf device (pciex or pci),
 *   whose bdf (if pciex) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - ecrcreq-u cascades up to the root complex which must report it with an ecrc
 *   ereport and any switches on route can optionally raise an ecrc ereport.
 *
 * Additionally, as the root complex will just throw away the packet, we may
 * eventually get a cto - so use an nr-d at the pciex leaf or bridge to get
 * the appropriate behaviour.
 *
 * We can always recognize what sort of fault this is from the ecrc (with no
 * cto) at the root complex. Recognizing which leaf device may be implicated
 * can be done from the cto ereport (for a hardened leaf driver) or for a
 * non-hardened leaf using the source-id payload of the ecrc.
 */
prop error.io.pciex.flt-f-ecrcreq-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ecrcreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.source-f-ecrcreq-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> {
	BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.source-f-ecrcreq-u@pcibus/pcidev/pcifn (0)->
    ereport.io.service.lost@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    ereport.io.service.degraded@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.source-f-ecrcreq-u@pcibus[b]/pcidev[d]/pcifn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pciex.flt-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ecrcreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-nf-ecrcreq-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> {
	BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.source-nf-ecrcreq-u@pcibus/pcidev/pcifn (1)->
    ereport.io.service.unaffected@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    error.io.service.restored@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.source-nf-ecrcreq-u@pcibus[b]/pcidev[d]/pcifn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pciex.ecrcreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ecrcreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.ecrcreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_SWD || IS_SWU };

/*
 * upstream completion with ecrc error.
 *
 * - flt-ecrccomp-u is just on the pciex node which generated the fault.
 * - source-ecrccomp-u cascades down to at least one leaf device (pciex or pci),
 *   whose bdf (if pciex) must match the source-id in the payload of the
 *   ereport generated from the root complex.
 * - ecrccomp-u cascades up to the root complex, which should report it with an
 *   ecrc ereport and any switches on route can optionally raise an ecrc
 *   ereport.
 *
 * Additionally, as the root complex will just throw away the packet, we'll
 * eventually get a cto - so use an flt-nr-u at the pciex leaf or bridge to get
 * the appropriate behaviour.
 *
 * We can always recognize what sort of fault this from the ecrc/cto from the
 * root complex. Recognizing which leaf device may be implicated can be done
 * using either the source-id payload of the ecrc or the target-ma ereport if
 * available.
 */
prop error.io.pciex.flt-f-ecrccomp-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ecrccomp-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.service.lost@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.service.degraded@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.source-f-ecrccomp-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> {
	SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.source-f-ecrccomp-u@pcibus/pcidev/pcifn (0)->
    ereport.io.service.lost@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    ereport.io.service.degraded@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.source-f-ecrccomp-u@pcibus[b]/pcidev[d]/pcifn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pciex.flt-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ecrccomp-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.service.unaffected@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.service.restored@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.source-nf-ecrccomp-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> {
	SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC };

prop error.io.pciex.source-nf-ecrccomp-u@pcibus/pcidev/pcifn (1)->
    ereport.io.service.unaffected@pcibus/pcidev/pcifn { IS_PCI_LEAF },
    error.io.service.restored@pcibus/pcidev/pcifn { IS_PCI_LEAF };

prop error.io.pciex.source-nf-ecrccomp-u@pcibus[b]/pcidev[d]/pcifn[f] (1)->
    ereport.io.pciex.tl.ecrc@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pciex.ecrccomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ecrccomp-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.ecrccomp-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ecrc@pciexbus/pciexdev/pciexfn { IS_SWD || IS_SWU };

/*
 * no response to downstream requester
 *
 * - nr-d will effectively cascade downstream to the requester. The fault here
 *   is always at the root complex. For a hardened leaf device driver, we will
 *   always be able to recognize this as the requester will report this as a
 *   cto. For non-hardened leaf devices, no cto will be reported, and though we
 *   should still see a nonfatal error reported from the root complex
 *   identifying the leaf device, we won't actually be informed that the error
 *   was a cto.
 */
prop error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.cto@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.cto@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

/*
 * no response to upstream requester
 *
 * - flt-nr-u is just on the pciex node which generated the fault.
 * - nr-u will effectively cascade upstream to the root complex which will
 *   report it as a cto.
 *
 * We have to use target-ma to informs us which device failed to respond.
 */
prop error.io.pciex.flt-nr-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.nr-u@pciexbus/pciexdev/pciexfn,
    error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nr-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.nr-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.nr-u@pciexrc/pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.cto@pciexrc;

prop error.io.pciex.nr-u@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-ma@pciexrc;

/*
 * downstream malformed tlp
 *
 * This will cascade downstream to the receiver which will report it as an mtlp.
 * For non-hardened leaf drivers, no mtlp will be reported, and though we should
 * still see a fatal error reported from the root complex identifying the leaf
 * device, we won't actually be informed that the error was a mtlp.
 * Note that sw-mtlp-d is to handle the case where the switch is actually
 * the target of the packet (config request etc).
 */
prop error.io.pciex.mtlp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.sw-mtlp-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.mtlp-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;

prop error.io.pciex.mtlp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.mtlp-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.mtlp@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.mtlp-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.mtlp@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.sw-mtlp-d@pciexbus/pciexdev/pciexfn (2)->
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn { IS_SWU },
    ereport.io.pciex.tl.mtlp@pciexbus/pciexdev/pciexfn { IS_SWU };

/*
 * upstream malformed tlp
 *
 * This will cascade upstream to the receiver which will report it as an mtlp.
 */
prop error.io.pciex.mtlp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-mtlp-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (1)->
    ereport.io.pciex.tl.mtlp@pciexrc<> { BDF_IS_LEAF && BDF_IS_UNDER_RC };

prop error.io.pciex.source-mtlp-u@pcibus[b]/pcidev[d]/pcifn[f] (1)->
    ereport.io.pciex.tl.mtlp@pciexrc<> { PCIBDF_IS_UNDER_RC };

/*
 * downstream completer aborts
 *
 * This could be the fault of the root complex or a switch reporting an internal
 * error, or of the leaf device sending an invalid request (the latter is
 * handled by the badreq-u case below).
 *
 * This is reported by the completer or by an intervening downstream switch
 * port. The completer abort response propagates down to the initiator which
 * will set the legacy pci bit rta.
 *
 * The fault can always be recognized by the ca ereport from the root complex
 * or downstream switch port. The originator of the request can be recognized
 * by the rta for a hardened driver or by using the source-id payload of the
 * ca ereport for a non-hardened driver.
 *
 * Note that there is no ur-d (we assume that a ur reported by the root complex
 * is always due to a badreq-u - see below).
 */
prop error.io.pciex.flt-ca-d@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.ca-d@pciexrc/pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.tl.ca@pciexrc;

prop error.io.pciex.ca-d@pciexrc/pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.sec-sta@pciexrc;

prop error.io.pciex.flt-ca-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-ca-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (2)->
    ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn,
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.flt-ca-d@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>; 

prop error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.rta@pciexbus/pciexdev/pciexfn { IS_BDG };

prop error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.rta@pciexbus/pciexdev/pciexfn { IS_LEAF };

/*
 * upstream unexpected requests
 *
 * This could be the fault of a device behind a PCI Express/PCI(X) bridge not
 * responding, or of the root complex sending an invalid request (the latter
 * case is handled by badreq-d below).
 *
 * This is reported as a ur by the completer, which for non-posted reqs sets the
 * appropriate error bit in the completion message to the initiator which will
 * set the legacy pci bit sec-ma.
 *
 * The fault can always be recognized from the sec-ma bit at the root complex.
 *
 * If the fault was with the root complex, then we don't care which leaf is
 * involved.
 * 
 * If the fault originated from a pci device behind a PCI Express/PCI(X) bridge
 * we can identify the leaf device from the target-ma ereport if available or
 * from the source-id payload of the sec-rma ereport from the bridge.
 */
prop error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG };

prop error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pciex.tl.ur@pciexbus/pciexdev/pciexfn { IS_LEAF || IS_BDG };

prop error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.ur@pciexbus/pciexdev/pciexfn { IS_SWU };

prop error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ur-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.ur-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ur-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.ur-u@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-ma@pciexrc;

/*
 * upstream completer aborts
 *
 * This could be the fault of the leaf device/bridge/upstream switch port
 * reporting an internal error, or of the root complex sending an invalid
 * request (the latter case is handled by badreq-d below).
 *
 * This is reported as a ca by the completer. The completer (for non-posted
 * requested) sends the appropriate error bits in the completion message to
 * the initiator which will set the legacy pci bit sec-rta.
 *
 * The fault can always be recognized from the sec-rta bit at the root complex.
 *
 * If the fault was with a PCI Express leaf with a hardened driver, then we
 * will identify the device from the ca ereport.
 *
 * If the fault was with a PCI Express leaf with a non-hardened driver, then we
 * can still identify the leaf device from the source-id payload of the nonfatal
 * message ereport from the root complex or from the target-rta ereport.
 *
 * If the fault originated from a PCI(X) device behind a PCI Express/PCI(X)
 * bridge, and it's driver is hardened, we can identify the device from the PCI
 * sta ereport or from the source-id payload of the sec-rta ereport from the
 * bridge.
 *
 * If the fault originated from a PCI(X) device behind a PCI Express/PCI(X)
 * bridge, and its driver is not hardened we can only identify the leaf device
 * from the target-rta ereport if available or from the source-id payload of
 * the sec-rta ereport from the bridge.
 */
prop error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn
	{ IS_SWU || IS_LEAF || IS_BDG };

prop error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sta@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sta@pciexbus/pciexdev/pciexfn { IS_SWU || IS_BDG };

prop error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn { IS_SWU || IS_BDG };

prop error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn (2)->
    error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.ca-u@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-rta@pciexrc;

/*
 * upstream bad request
 *
 * When detecting bad data on a request the completer (or any switch on the
 * way to the completer) may report ur or ca. If the switch detects the problem
 * first then the request doesn't get forwarded on to the completer.
 *
 * These are reported as ur/ca ereports. For non-posted requests, the reporter
 * then sends the appropriate error bits in the completion message to the
 * initiator which will set the legacy pci bits ma or rta.
 *
 * For badreq-u, the ca/ur ereports contain a source-id payload that identifies
 * the initiator.
 * - flt-badreq-u represents the initiator that caused the fault. This may
 *   be a child pci device in which case flt-badreq-u is generated in pci.esc
 * - badreq-u propagates up to the root complex.
 *
 * The fault can always be recognized by the ca/ur ereport from the root
 * complex or downstream switch port. The originator of the request can be
 * recognized by the rta/ma for a hardened driver or by using the source-id
 * payload of the ca/ur ereport for a non-hardened driver.
 *
 * Note that handling of badreq-u where source and detector are both pciexfn
 * has to be handled specially to avoid path name matching.
 */
prop error.io.pciex.flt-badreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.badreq-u@pciexrc/pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexrc;

prop error.io.pciex.flt-badreq-u@pciexbus[b]/pciexdev[d]/pciexfn[f] (0)->
    ereport.io.pciex.tl.ur@pciexrc<> {
        BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC},
    ereport.io.pciex.tl.ca@pciexrc<> {
        BDF_IS_LEAF && SOURCE_ID_MATCHES_BDF && BDF_IS_UNDER_RC};

prop error.io.pci.badreq-pw-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ur@pciexrc<> { PCIBDF_IS_UNDER_RC },
    ereport.io.pciex.tl.ca@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pci.badreq-drw-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ur@pciexrc<> { PCIBDF_IS_UNDER_RC },
    ereport.io.pciex.tl.ca@pciexrc<> { PCIBDF_IS_UNDER_RC };

prop error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn { IS_SWD };

prop error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.badreq-u@pciexbus/pciexdev { IS_LEAF };

prop error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn (0)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.badreq-u@pciexbus[b]/pciexdev[d] (0)->
    ereport.io.pciex.tl.ur@pciexfn {
	(confprop(asru(pciexfn), TOPO_PCI_EXCAP) == "pciexswd") &&
	(!payloadprop_defined("source-valid") ||
	payloadprop("source-valid") == 0 ||
	(payloadprop("source-id") & 0xfff8) == ((b << 8) | (d << 3))) },
    ereport.io.pciex.tl.ca@pciexfn {
	(confprop(asru(pciexfn), TOPO_PCI_EXCAP) == "pciexswd") &&
	(!payloadprop_defined("source-valid") ||
	payloadprop("source-valid") == 0 ||
	(payloadprop("source-id") & 0xfff8) == ((b << 8) | (d << 3))) };

prop error.io.pci.badreq-pw-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ur@pciexbus/pciexdev/pciexfn { IS_SWD &&
	PCIBDF_IS_UNDER_DEV },
    ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn { IS_SWD &&
	PCIBDF_IS_UNDER_DEV };

prop error.io.pci.badreq-drw-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.tl.ur@pciexbus/pciexdev/pciexfn { IS_SWD &&
	PCIBDF_IS_UNDER_DEV },
    ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn { IS_SWD &&
	PCIBDF_IS_UNDER_DEV };

prop error.io.pciex.flt-badreq-u@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn { IS_LEAF },
    ereport.io.pci.rta@pciexbus/pciexdev/pciexfn { IS_LEAF };

/*
 * downstream bad request
 *
 * When detecting bad data on a request the completer (or any switch on the
 * way to the completer) may report ur or ca. If the switch detects the problem
 * first then the request doesn't get forwarded on to the completer.
 *
 * These are reported as ur/ca ereports (except where the completer is a non-
 * hardened leaf driver when all we get is a nonfatal error from the root
 * complex identifying the leaf device). The reporter then sends the appropriate
 * error bits in the completion message to the initiator which will set the
 * legacy pci bits ma or rta (oddly there is no equivalent in pcie error
 * reporting).
 */
prop error.io.pciex.badreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.badreq-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;

prop error.io.pciex.badreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn { IS_LEAF },
    error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop error.io.pciex.badreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn,
    error.io.pciex.flt-ca-u@pciexbus/pciexdev/pciexfn,
    error.io.pci.badreq-pw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.badreq-drw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * Stub unused legacy pci ereports at root complex.
 * Stub tl.uc as we can't do anything useful with it (we should eventually
 * get a cto which we can do something with - a uc without a cto is a genuinely
 * spurious completion which is at least harmless).
 * Stub messages that the root complex sends to itself.
 * Stub mce/mue/ce/nr/noadverr.
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

event error.io.pciex.discard_rc@pciexrc;

event ereport.io.pciex.tl.uc@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.noadverr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.correctable@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.a-nonfatal@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.fatal@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.nr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.nr@pciexrc{within(5s)};
event ereport.io.pci.ma@pciexrc{within(5s)};
event ereport.io.pci.rta@pciexrc{within(5s)};
event ereport.io.pci.sta@pciexrc{within(5s)};
event ereport.io.pci.dpe@pciexrc{within(5s)};
event ereport.io.pci.mdpe@pciexrc{within(5s)};
event ereport.io.pci.sserr@pciexrc{within(5s)};
event ereport.io.pciex.tl.uc@pciexrc{within(5s)};
event ereport.io.pciex.noadverr@pciexrc{within(5s)};
event ereport.io.pciex.a-nonfatal@pciexrc{within(5s)};
event ereport.io.pciex.rc.ce-msg@pciexrc{within(5s)};
event ereport.io.pciex.rc.mce-msg@pciexrc{within(5s)};
event ereport.io.pciex.rc.mue-msg@pciexrc{within(5s)};

event upset.io.pciex.discard_uc@pciexbus/pciexdev/pciexfn;
event upset.io.pciex.discard@pciexbus/pciexdev/pciexfn;
event upset.io.pciex.discard@pciexrc;

prop upset.io.pciex.discard_uc@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.uc@pciexbus/pciexdev/pciexfn { IS_BDG };

prop upset.io.pciex.discard_uc@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.tl.uc@pciexbus/pciexdev/pciexfn { IS_LEAF };

prop upset.io.pciex.discard@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pci.nr@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.noadverr@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.correctable@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.a-nonfatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.fatal@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.discard_rc@pciexrc (1)->
    ereport.io.pciex.rc.fe-msg@pciexrc { SOURCE_ID_MATCHES_OWN_BDF },
    ereport.io.pciex.rc.nfe-msg@pciexrc { SOURCE_ID_MATCHES_OWN_BDF },
    ereport.io.pciex.rc.ce-msg@pciexrc { SOURCE_ID_MATCHES_OWN_BDF };

prop upset.io.pciex.discard@pciexrc (1)->
    error.io.pciex.discard_rc@pciexrc,
    ereport.io.pci.nr@pciexrc,
    ereport.io.pciex.noadverr@pciexrc,
    ereport.io.pciex.a-nonfatal@pciexrc,
    ereport.io.pciex.rc.ce-msg@pciexrc,
    ereport.io.pciex.rc.mce-msg@pciexrc,
    ereport.io.pciex.rc.mue-msg@pciexrc,
    ereport.io.pciex.tl.uc@pciexrc,
    ereport.io.pci.ma@pciexrc,
    ereport.io.pci.rta@pciexrc,
    ereport.io.pci.sta@pciexrc,
    ereport.io.pci.dpe@pciexrc,
    ereport.io.pci.mdpe@pciexrc,
    ereport.io.pci.sserr@pciexrc;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * rules for PCI Express to PCI bridge propagations
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

event error.io.pci.retry-to-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.badreq-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.badreq-drw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.ma-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.ta-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.ape-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-ape-u@pcibus/pcidev/pcifn;
event error.io.pci.source-f-perr-u@pcibus/pcidev/pcifn;
event error.io.pci.source-nf-perr-u@pcibus/pcidev/pcifn;
event error.io.pci.target-ma-d@pcibus/pcidev/pcifn;
event error.io.pci.target-rta-d@pcibus/pcidev/pcifn;
event error.io.pci.f-dpdata-pw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.nf-dpdata-pw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.f-dpdata-dw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.nf-dpdata-dw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.f-dpdata-dr-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.nf-dpdata-dr-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.dpdata-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.dpdata-dw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.dpdata-dr-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.perr-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.perr-dw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.perr-dr-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.serr-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pcix.scpe-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pcix.source-scpe-u@pcibus/pcidev/pcifn;
event error.io.pcix.spl-comp-ma-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pcix.spl-comp-ta-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pcix.spl-comp-ma-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pcix.spl-comp-ta-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pcix.uscmd@pciexbus/pciexdev/pciexfn;

event ereport.io.pcix.sec-spl-dis@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.uscmd@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-perr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-uadr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-uat@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-serr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-tex@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-rma@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-rta@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-ma-sc@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pciex.bdg.sec-ta-sc@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.dto@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.sec-rta@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.sec-ma@pciexbus/pciexdev/pciexfn{within(5s)};

/*
 * propagations from pci express onto pci/pci-x
 */

/*
 * poisoned tlps propagate as parity/ecc errors.
 */
prop error.io.pciex.f-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.f-dpdata-pw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.f-dpdata-dw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop error.io.pciex.nf-poisreq-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.nf-dpdata-pw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>,
    error.io.pci.nf-dpdata-dw-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop error.io.pciex.f-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.f-dpdata-dr-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop error.io.pciex.nf-poiscomp-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.nf-dpdata-dr-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

/*
 * ca-d only propagates on to pci bus if non-posted access
 */
prop error.io.pciex.ca-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn,
    error.io.pci.ta-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;

/*
 * nr-d only propagates on to pci bus if non-posted access
 */
prop error.io.pciex.nr-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn,
    error.io.pci.nr-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn,
    error.io.pci.ta-drw-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;

/*
 * propagations from pci/pci-x onto pci express
 */

/*
 * ma-u will only propagate on to pciex bus for non-posted accesses. It
 * is then represented as an unsupported request.
 */
prop error.io.pci.ma-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    ereport.io.pciex.tl.ur@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ur-u@pciexbus/pciexdev/pciexfn;

prop error.io.pci.ma-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (2)->
    ereport.io.pci.sec-ma@pciexbus/pciexdev/pciexfn,
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;

prop error.io.pci.target-ma-d@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-rma@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

/*
 * ta-u will only propagate on to pciex bus for non-posted accesses. It is
 * then represented as a completer abort.
 */
prop error.io.pci.ta-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    ereport.io.pci.sta@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn;

prop error.io.pci.ta-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (2)->
    ereport.io.pci.sec-rta@pciexbus/pciexdev/pciexfn,
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;

prop error.io.pci.target-rta-d@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-rta@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

/*
 * PERR# on a delayed write is represented as an unsupported request
 */
prop error.io.pci.perr-dw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (1)->
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn;

prop error.io.pci.perr-dw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    error.io.pciex.flt-ur-u@pciexbus/pciexdev/pciexfn;

prop error.io.pci.perr-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (1)->
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn;

prop error.io.pci.perr-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;

prop error.io.pci.source-f-perr-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-perr@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pci.source-nf-perr-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-perr@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pci.perr-dr-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (1)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;

/*
 * If the bridge receives data with bad ecc/parity from pci/pci-x, it will
 * propagate onto pci express as a poisoned tlp
 */
prop error.io.pci.dpdata-dr-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (3)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-mdpe@pciexbus/pciexdev/pciexfn,
    error.io.pciex.poiscomp-u@pciexbus/pciexdev/pciexfn;

prop error.io.pci.dpdata-dr-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.mdpe@pciexbus/pciexdev/pciexfn;

prop error.io.pci.dpdata-dw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (1)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn;

prop error.io.pci.dpdata-dw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn,
    error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pci.dpdata-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (2)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn,
    error.io.pciex.poisreq-u@pciexbus/pciexdev/pciexfn;

prop error.io.pci.dpdata-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn;

/*
 * If the bridge sees an address or attribute parity error it is considered
 * a fatal error.
 */
prop error.io.pci.ape-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (2)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn,
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn;

prop error.io.pci.source-ape-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-uat@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV },
    ereport.io.pciex.bdg.sec-uadr@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pci.ape-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    ereport.io.pci.sec-rserr@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.bdg.sec-serr@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn;

/*
 * If the bridge sees a split completion error (pci-x only) it could
 * result in a number of things
 * - unrecovered split completion message data error (uscmd). This would
 *   happen on a pio write. A completer abort is returned to the initiator.
 * - for various faults in the split completion (eg address parity error)
 *   we will respond with a target abort (which the child device will treat
 *   as a split completion ta)
 * - for other faults we can't tell who send the split completion and so
 *   just drop the request (which the child device sees as a split
 *   completion ma)
 */
prop error.io.pcix.scpe-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    ereport.io.pci.sec-dpe@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-rserr@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.bdg.sec-serr@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn,
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn;

prop error.io.pcix.source-scpe-u@pcibus[b]/pcidev[d]/pcifn[f] (0)->
    ereport.io.pciex.bdg.sec-uat@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV },
    ereport.io.pciex.bdg.sec-uadr@pciexbus/pciexdev/pciexfn { IS_BDG &&
	BDF_IS_PCI_LEAF && SOURCE_ID_MATCHES_BDF && PCIBDF_IS_UNDER_DEV };

prop error.io.pcix.scpe-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (1)->
    error.io.pcix.uscmd@pciexbus/pciexdev/pciexfn,
    error.io.pcix.spl-comp-ma-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn,
    error.io.pcix.spl-comp-ta-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;

prop error.io.pcix.uscmd@pciexbus/pciexdev/pciexfn (5)->
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sta@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.tl.ca@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.bdg.uscmd@pciexbus/pciexdev/pciexfn;

/*
 * Similarly a child device may have responded with a master abort or
 * target abort to one of our split competions. The hardware just logs these.
 */
prop error.io.pcix.spl-comp-ma-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (3)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-spl-dis@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.bdg.sec-ma-sc@pciexbus/pciexdev/pciexfn;

prop error.io.pcix.spl-comp-ma-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    ereport.io.pci.sec-ma@pciexbus/pciexdev/pciexfn;

prop error.io.pcix.spl-comp-ta-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (4)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-spl-dis@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.bdg.sec-ta-sc@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-rta@pciexbus/pciexdev/pciexfn;

/*
 * SERR# is considered fatal
 */
prop error.io.pci.serr-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (3)->
    error.io.pciex.fatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-rserr@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.bdg.sec-serr@pciexbus/pciexdev/pciexfn;

/*
 * Retry time-out is nonfatal. The initial requester has stopped retrying so
 * there's nothing else the hardware can do but flag the error.
 */
prop error.io.pci.retry-to-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (2)->
    error.io.pciex.nonfatal@pciexbus/pciexdev/pciexfn,
    ereport.io.pciex.bdg.sec-tex@pciexbus/pciexdev/pciexfn;

prop error.io.pci.retry-to-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    ereport.io.pci.sta@pciexbus/pciexdev/pciexfn,
    error.io.pciex.ca-u@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.dto@pciexbus/pciexdev/pciexfn;

/*
 * A bad dma request (eg with invalid address) propagates onto pci express
 * as a bad dma request. The end result may be a master abort or target abort
 * (depending on whether the child is pci-x or pci).
 */
prop error.io.pci.badreq-pw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.rta@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn;

prop error.io.pci.badreq-drw-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn (0)->
    error.io.pciex.badreq-u@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.ma@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.rta@pciexbus/pciexdev/pciexfn,
    ereport.io.pci.sec-sta@pciexbus/pciexdev/pciexfn;

/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * source- and target- propagations
 * 
 * The source- propagations cascade down to a leaf device, which can then have
 * its bdf matched against the source-id of various ereports. This is necessary
 * because for a number of cases the source-id represents the original requester
 * of the packet which may be different from the detector of the error (which
 * could be a bridge or switch).
 *
 * A Root Complex driver may generate "target-" ereports when knowledge of the
 * physical address associated with a fault allows the target device to be
 * determined. This is not a requirement of the Diagnosis Engine, but can be
 * valuable when available.
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */
event error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.source-f-poiscomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-poiscomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pci.source-f-dpdata-r-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-nf-dpdata-r-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-f-dpdata-w-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pci.source-nf-dpdata-w-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.source-f-ecrcreq-u@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.source-nf-ecrcreq-u@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.source-f-ecrccomp-u@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.source-nf-ecrccomp-u@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;
event error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn/pciexbus/pciexdev/pciexfn;
event error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn/pcibus/pcidev/pcifn;
event error.io.pciex.source-mtlp-u@pcibus/pcidev/pcifn/pcibus/pcidev/pcifn;

event ereport.io.pci.target-mdpe@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.target-rta@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pci.target-ma@pciexbus/pciexdev/pciexfn{within(5s)};

prop error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;

prop error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop error.io.pci.target-ma-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.target-ma@pciexbus/pciexdev/pciexfn;

prop error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;

prop error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop error.io.pci.target-rta-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.target-rta@pciexbus/pciexdev/pciexfn;

prop error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;

prop error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;

prop error.io.pci.target-mdpe-d@pciexbus/pciexdev/pciexfn (0)->
    ereport.io.pci.target-mdpe@pciexbus/pciexdev/pciexfn;

prop error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-f-poisreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.source-f-dpdata-w-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-nf-poisreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.source-nf-dpdata-w-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-f-poiscomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-f-poiscomp-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-nf-poiscomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-nf-poiscomp-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-f-poiscomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.source-f-dpdata-r-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-nf-poiscomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pci.source-nf-dpdata-r-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-f-ecrcreq-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-nf-ecrcreq-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-f-ecrcreq-u@pcibus/pcidev/pcifn (1)->
    error.io.pciex.source-f-ecrcreq-u@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-nf-ecrcreq-u@pcibus/pcidev/pcifn (1)->
    error.io.pciex.source-nf-ecrcreq-u@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-f-ecrccomp-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-nf-ecrccomp-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-f-ecrccomp-u@pcibus/pcidev/pcifn (1)->
    error.io.pciex.source-f-ecrccomp-u@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-nf-ecrccomp-u@pcibus/pcidev/pcifn (1)->
    error.io.pciex.source-nf-ecrccomp-u@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn/pciexbus<>/pciexdev<>/pciexfn<>;
    
prop error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn (1)->
    error.io.pciex.source-mtlp-u@pciexbus/pciexdev/pciexfn/pcibus<>/pcidev<>/pcifn<>;
    
prop error.io.pciex.source-mtlp-u@pcibus/pcidev/pcifn (1)->
    error.io.pciex.source-mtlp-u@pcibus/pcidev/pcifn/pcibus<>/pcidev<>/pcifn<>;
    
/*
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 * stub unused pciex-pci bridge ereports
 * - ignore usc/sec-unex-spl
 * - ignore sec-spl-or/sec-spl-dly as these aren't really faults (tuning info)
 * - ignore ecc.ue ereports (we get everything we need from dpe/mdpe)
 * - ignore ecc.ce ereports for now (could do serd on these)
 * +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 */

event ereport.io.pciex.bdg.usc@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-unex-spl@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-spl-or@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-spl-dly@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-ecc.ce-addr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-ecc.ce-attr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-ecc.ce-data@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-ecc.ue-addr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-ecc.ue-attr@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-ecc.ue-data@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-s-ce@pciexbus/pciexdev/pciexfn{within(5s)};
event ereport.io.pcix.sec-s-ue@pciexbus/pciexdev/pciexfn{within(5s)};

event upset.io.pciex.discard-bdg@pciexbus/pciexdev/pciexfn;

prop upset.io.pciex.discard-bdg@pciexbus/pciexdev/pciexfn (1)->
    ereport.io.pciex.bdg.usc@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-unex-spl@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-spl-or@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-spl-dly@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-ecc.ce-addr@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-ecc.ce-attr@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-ecc.ce-data@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-ecc.ue-addr@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-ecc.ue-attr@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-ecc.ue-data@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-s-ce@pciexbus/pciexdev/pciexfn,
    ereport.io.pcix.sec-s-ue@pciexbus/pciexdev/pciexfn;
