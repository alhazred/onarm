#!/sbin/sh
#
# Copyright 2006 Sun Microsystems, Inc.  All rights reserved.
# Use is subject to license terms.
#
# ident	"%Z%%M%	%I%	%E% SMI"
#

# Function: check_add_drv()
#
# This function will check if the module has an entry in etc/name_to_major
# If not simply calls add_drv with the arguments given. If there is
# such an entry in name_to_major file, it adds entries in driver_aliases
# driver_classes and minor_perm if necessary.
# The syntax of this function is the same as add_drv. 

check_add_drv()
{
	if [ "$BASEDIR" = "" ]
	then
		BASEDIR=/  
	fi
	alias=""
	class=""
	ADD_ALIAS=0
	ADD_CLASS=0
	ADD_MINOR=0
	OPTIND=1
	IS_NET_DRIVER=0

	cmd="add_drv"

	NO_CMD=

	while getopts i:b:m:c:N  opt
	do
		case $opt in
			N )	NO_CMD=1;;
			i )	ADD_ALIAS=1	
				alias=$OPTARG
				cmd=$cmd" -i '$alias'"
				;;
			m )	ADD_MINOR=1
				minor=$OPTARG
				cmd=$cmd" -m '$minor'"
				;;
			c)	ADD_CLASS=1
				class=$OPTARG
				cmd=$cmd" -c $class"
				;;
			b)	BASEDIR=$OPTARG
				cmd=$cmd" -b $BASEDIR"
				;;
			\?) 	echo "check_add_drv can not handle this option"
				return
				;;
			esac
	done 
	shift `/usr/bin/expr $OPTIND - 1`
	
	drvname=$1

	cmd=$cmd" "$drvname

	drvname=`echo $drvname | /usr/bin/sed 's;.*/;;g'`

	/usr/bin/grep "^$drvname[ 	]" $BASEDIR/etc/name_to_major >  /dev/null 2>&1

	if [ "$NO_CMD" = "" -a $? -ne 0 ] 
	then
		eval $cmd
	else	
		# entry already in name_to_major, add alias, class, minorperm
		# if necessary
		if [ $ADD_ALIAS = 1 ]	
		then
			for i in $alias
			do
				/usr/bin/egrep "^$drvname[ 	]+$i" $BASEDIR/etc/driver_aliases>/dev/null 2>&1
				if [ $? -ne 0 ]
				then
					echo "$drvname $i" >> $BASEDIR/etc/driver_aliases	
				fi
			done
		fi

		if [ $ADD_CLASS = 1 ]
		then
			/usr/bin/egrep "^$drvname[ 	]+$class( |	|$)" $BASEDIR/etc/driver_classes > /dev/null 2>&1
			if [ $? -ne 0 ]
			then 
				echo "$drvname\t$class" >> $BASEDIR/etc/driver_classes
			fi
		fi

		if [ $ADD_MINOR = 1 ]
		then
			/usr/bin/grep "^$drvname:" $BASEDIR/etc/minor_perm > /dev/null 2>&1
			if [ $? -ne 0 ]
			then 
				minorentry="$drvname:$minor"
				echo $minorentry >> $BASEDIR/etc/minor_perm
			fi
		fi

	fi


}


# Function : addlsimegatargets
# This function adds the targets from 0-128 into the
# ${BASEDIR}/kernel/drv/sd.conf file.

addlsimegatargets()
{
	SDCONF=${BASEDIR}/kernel/drv/sd.conf
	HEADER="# LSIMEGA AUTOGENERATED CONFIGURATION : START (DO NOT DELETE/ALTER THIS LINE)"
	FOOTER="# LSIMEGA AUTOGENERATED CONFIGURATION : END (DO NOT DELETE/ALTER THIS LINE)"
	HEADER2="# WARNING : LINES ADDED WITHIN THIS LSIMEGA CONF SECTION"
        HEADER3="# WOULD GET DELETED WHEN THE LSIMEGA DRIVER PACKAGE IS REMOVED"
        LINEENDPATTERN="parent=\"lsimega\""
	GREP=/usr/bin/grep
	CP=/usr/bin/cp
	MV=/usr/bin/mv
	RM=/usr/bin/rm
	CHMOD=/usr/bin/chmod
	CHOWN=/usr/bin/chown
	CHGRP=/usr/bin/chgrp
	target=0

	# check if $SDCONF exists
	if [ ! -f $SDCONF ]
	then
		echo "ERROR : $SDCONF file does not exist"
		exit 1
	fi

	# Force correct attributes of $SDCONF to allow successful
	# interim build upgrade
	$CHMOD 644 $SDCONF
	$CHOWN root $SDCONF
	$CHGRP sys $SDCONF

	$GREP -w "$HEADER" $SDCONF >/dev/null 2>&1
	slstatus=$?
	$GREP -w "$FOOTER" $SDCONF >/dev/null 2>&1
	elstatus=$?
	$GREP -w "$LINEENDPATTERN" $SDCONF >/dev/null 2>&1
	lestatus=$?
	# If any lsimega related entries exist
	# remove them 
	if [ $slstatus -eq 0 -o $elstatus -eq 0 -o $lestatus -eq 0 ]
	then
		# Shouldn't enter this condition unless the
		# file has been corrupted 
		# do a dirty remove
		$RM -f /tmp/$$.conf >/dev/null 2>&1
		cat $SDCONF | $GREP -v "$LINEENDPATTERN" | $GREP -v  "$HEADER" \
                        | $GREP -v "$FOOTER" | $GREP -v "$HEADER2" \
                        | $GREP -v "$HEADER3" >> /tmp/$$.conf
		if [ $? -eq 0 ]
		then
			$CP /tmp/$$.conf $SDCONF
			$RM -f /tmp/$$.conf >/dev/null 2>&1
		else
			$RM -f /tmp/$$.conf >/dev/null 2>&1
			echo "ERROR while cleaning up lsimega related info in $SDCONF file"
			# return, since something bad happened
			# and we don't want to continue adding
			# more lsimega related lines
			exit 1
		fi
	fi

	# Store the lines to be added
	lsimegalines="${HEADER}\n"
	lsimegalines="${lsimegalines}${HEADER2}\n"
	lsimegalines="${lsimegalines}${HEADER3}\n"

	while [ $target -le 128 ]
	do
		lsimegalines="${lsimegalines}name=\"sd\" class=\"scsi\" target=$target lun=0 parent=\"lsimega\";\n"
		target=`expr $target + 1`
	done

	lsimegalines="$lsimegalines$FOOTER"

	# add a new line if the last line of $SDCONF
	# file is not empty (This is required to make sure
	# that we don't end up piling newlines every time
	# we add/remove this package)

	lastline=`tail -1 $SDCONF`
	if [ "X$lastline" != "X" ]
	then
		lsimegalines="\n$lsimegalines"
	fi

	# Copy the $SDCONF into /tmp as a backup
	$RM -f /tmp/sd.conf.$$ >/dev/null 2>&1
	$CP -p $SDCONF /tmp/sd.conf.$$ >/dev/null 2>&1

	# Now put all the lines into SDCONF file
	# in one shot
	echo $lsimegalines >> $SDCONF
	if [ $? -ne 0 ]
	then
		echo "ERROR occurred while adding lsimega targets into $SDCONF file"
		# Revert back the backup file in case we added a few lines and 
		# then the error happened
		$MV /tmp/sd.conf.$$ $SDCONF > /dev/null 2>&1
		exit 1
	fi
	$RM -f /tmp/sd.conf.$$ >/dev/null 2>&1
}


addlsimegatargets

# We should all use main PCI ID entries. The 4-tuple entries are used to patch 
# specific cards, or they will be wrongly matched by other drivers.
# "amr" driver contains entry "pci1000,532"
# "ncrs" contains entry "pci1000,2"

check_add_drv -i '"pci1028,13" "pci1000,407" "pci1000,407.1000.532" "pci1000,408" "pci1000,408.1000.2" "pci1000,1960"' -b "$BASEDIR" -c scsi lsimega
